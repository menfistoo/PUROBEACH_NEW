{% extends "base.html" %}

{% set page_title = "Mapa" %}
{% set hide_header = true %}

{% block title %}Mapa - PuroBeach{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/customer-search.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/date-picker.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/reservation-panel.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/new-reservation-panel.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/conflict-resolution-modal.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/safeguard-modal.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/map-search.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/map-blocks.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/map-temporary.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/waitlist.css') }}">
<style>
    /* =============================================================================
   MOBILE-FIRST MAP PAGE LAYOUT
   ============================================================================= */

    /* Override parent containers for full-height map layout */
    .main-content:has(.map-page) {
        overflow: hidden;
        min-height: 0;
        /* Allow flex shrinking */
    }

    /* Full viewport height layout - negate content-wrapper padding */
    .content-wrapper:has(.map-page) {
        padding: 0;
        overflow: hidden;
        height: 100%;
        /* Critical: these ensure the container doesn't grow beyond viewport */
        min-height: 0;
        max-height: calc(100vh - 60px);
        max-height: calc(100dvh - 60px);
    }

    .map-page {
        display: flex;
        flex-direction: column;
        height: 100%;
        /* Fill the content-wrapper */
        overflow: hidden;
        background: var(--color-background);
        /* Prevent any content from expanding beyond */
        max-height: 100%;
    }

    /* =============================================================================
   TOOLBAR - Ultra Compact, Dark
   ============================================================================= */
    .map-toolbar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 6px 12px;
        background: var(--color-secondary);
        color: white;
        min-height: 44px;
        gap: 8px;
        flex-shrink: 0;
    }

    .toolbar-group {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .toolbar-btn {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: none;
        background: rgba(255, 255, 255, 0.15);
        color: white;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
        font-size: 14px;
    }

    .toolbar-btn:hover,
    .toolbar-btn:active {
        background: rgba(255, 255, 255, 0.25);
    }

    .toolbar-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .date-display {
        font-weight: 600;
        font-size: 13px;
        color: white;
        min-width: 70px;
        text-align: center;
        cursor: pointer;
        padding: 6px 10px;
        border-radius: 6px;
        transition: background 0.2s;
    }

    .date-display:hover {
        background: rgba(255, 255, 255, 0.1);
    }

    /* Gold Zone Selector */
    .zone-selector-gold {
        background: linear-gradient(135deg, #D4AF37 0%, #B8960C 100%);
        color: white;
        font-weight: 600;
        font-size: 12px;
        border: none;
        border-radius: 16px;
        padding: 6px 14px;
        cursor: pointer;
        box-shadow: 0 2px 6px rgba(212, 175, 55, 0.4);
        min-width: 120px;
        text-align: center;
        appearance: none;
        -webkit-appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='10' viewBox='0 0 12 12'%3E%3Cpath fill='white' d='M6 8L2 4h8z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
        padding-right: 26px;
    }

    .zone-selector-gold:focus {
        outline: none;
        box-shadow: 0 0 0 3px rgba(212, 175, 55, 0.5);
    }

    /* =============================================================================
   STATS STRIP - Ultra Compact Horizontal
   ============================================================================= */
    .stats-strip {
        display: flex;
        justify-content: center;
        gap: 16px;
        padding: 4px 8px;
        background: white;
        border-bottom: 1px solid var(--color-border);
        flex-shrink: 0;
    }

    .stat-item {
        text-align: center;
        padding: 2px 8px;
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .stat-item .stat-value {
        font-size: 15px;
        font-weight: 700;
        color: var(--color-secondary);
        line-height: 1;
    }

    .stat-item .stat-label {
        font-size: 10px;
        text-transform: uppercase;
        color: var(--color-text-muted);
        letter-spacing: 0.3px;
    }

    .stat-item.stat-available .stat-value {
        color: var(--color-success);
    }

    .stat-item.stat-occupied .stat-value {
        color: var(--color-warning);
    }

    /* =============================================================================
   CANVAS INFO BAR (Map Editor Style)
   ============================================================================= */
    .canvas-info-bar {
        display: flex;
        align-items: center;
        padding: 3px 12px;
        background: #f8f9fa;
        border-bottom: 1px solid var(--color-border);
        font-size: 11px;
        color: var(--color-text-muted);
        gap: 6px;
        flex-shrink: 0;
        flex-wrap: wrap;
    }

    .info-group {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .info-label {
        color: #6c757d;
    }

    .info-value {
        color: var(--color-secondary);
        font-weight: 500;
    }

    .info-value.highlight {
        color: var(--color-primary);
        font-family: 'Monaco', 'Consolas', monospace;
        font-size: 11px;
        background: rgba(212, 175, 55, 0.1);
        padding: 2px 6px;
        border-radius: 4px;
    }

    .info-divider {
        width: 1px;
        height: 16px;
        background: #dee2e6;
    }

    .info-spacer {
        flex: 1;
    }

    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 4px;
    }

    .zoom-level {
        min-width: 45px;
        text-align: center;
        font-weight: 600;
    }

    .info-btn {
        width: 24px;
        height: 24px;
        border: 1px solid #dee2e6;
        background: white;
        border-radius: 4px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: var(--color-text-muted);
        transition: all 0.15s;
        font-size: 11px;
    }

    .info-btn:hover {
        background: var(--color-accent);
        border-color: var(--color-primary);
        color: var(--color-secondary);
    }

    /* Shortcuts Dropdown */
    .shortcuts-dropdown {
        width: 320px;
        font-size: 12px;
    }

    .shortcuts-section {
        margin-bottom: 12px;
    }

    .shortcuts-title {
        font-weight: 600;
        color: var(--color-secondary);
        margin-bottom: 6px;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .shortcut-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 4px 0;
        color: var(--color-text-muted);
    }

    .shortcut-row kbd {
        background: #f1f3f4;
        border: 1px solid #dadce0;
        border-radius: 3px;
        padding: 2px 6px;
        font-size: 11px;
        font-family: inherit;
        color: var(--color-secondary);
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
    }

    /* Hide info bar on very small screens */
    @media (max-width: 576px) {
        .canvas-info-bar {
            display: none;
        }
    }

    /* =============================================================================
   MAP CANVAS - Full Screen (Map Editor Style)
   ============================================================================= */
    /* Canvas viewport - matches map editor style */
    .map-canvas-wrapper {
        flex: 1 1 0%;
        /* Grow, shrink, but start at 0 (critical for flex containment) */
        position: relative;
        overflow: auto;
        /* Use auto instead of scroll for better behavior */
        background: #dee2e6;
        padding: 10px;
        /* Critical: min-height: 0 allows flex item to shrink below content size */
        min-height: 0;
        /* Isolate scrolling to this container */
        isolation: isolate;
        /* Center content using text-align (works with inline-block child) */
        text-align: center;
    }

    .map-canvas {
        /* Inline-block for centering via text-align */
        display: inline-block;
        /* Allow touch gestures for mobile */
        touch-action: pan-x pan-y pinch-zoom;
        /* Reset text-align for content */
        text-align: left;
        /* Margin auto for additional centering support */
        margin: 0 auto;
    }

    /* SVG container with shadow - like map editor */
    .map-canvas svg {
        background: #FAFAFA;
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        border-radius: 4px;
        display: block;
    }

    /* Hide zone rectangles - zone is shown in toolbar dropdown */
    .map-canvas .zone-group {
        display: none;
    }

    /* Loading State */
    .map-loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 10;
    }

    /* =============================================================================
   FLOATING ZOOM CONTROLS (FAB Style)
   ============================================================================= */
    .zoom-fab {
        position: fixed;
        /* Fixed so it stays visible always */
        bottom: 100px;
        /* Above bottom bar */
        right: 24px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 50;
    }

    .fab-btn {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        background: white;
        border: none;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        font-size: 18px;
        color: var(--color-secondary);
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .fab-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
    }

    .fab-btn:active {
        transform: scale(0.95);
    }

    /* =============================================================================
   BOTTOM ACTION BAR (Slides up on selection)
   ============================================================================= */
    .bottom-action-bar {
        position: fixed;
        bottom: 0;
        left: var(--sidebar-width, 260px);
        right: 0;
        background: white;
        border-top: 2px solid var(--color-primary);
        padding: 10px 16px;
        padding-bottom: max(10px, env(safe-area-inset-bottom));
        box-shadow: 0 -2px 12px rgba(0, 0, 0, 0.08);
        transform: translateY(100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.3s, left 0.3s ease;
        z-index: 100;
        visibility: hidden;
        pointer-events: none;
    }

    /* Adjust footer when sidebar is collapsed */
    html.sidebar-collapsed .bottom-action-bar {
        left: var(--sidebar-collapsed-width, 70px);
    }

    /* On mobile, footer goes full width */
    @media (max-width: 991px) {
        .bottom-action-bar {
            left: 0;
        }

        html.sidebar-collapsed .bottom-action-bar {
            left: 0;
        }
    }

    .bottom-action-bar.show {
        transform: translateY(0);
        visibility: visible;
        pointer-events: auto;
    }

    .selection-summary {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 12px;
        margin-bottom: 10px;
    }

    .selected-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        justify-content: center;
    }

    .selection-chip {
        display: inline-flex;
        align-items: center;
        padding: 5px 12px;
        background: var(--color-accent);
        border: 1.5px solid var(--color-primary);
        border-radius: 20px;
        font-size: 13px;
        font-weight: 600;
        color: var(--color-secondary);
    }

    .selection-chip .remove-chip {
        margin-left: 6px;
        cursor: pointer;
        opacity: 0.6;
        font-size: 10px;
    }

    .selection-chip .remove-chip:hover {
        opacity: 1;
    }

    .selection-meta {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 13px;
        color: var(--color-text-muted);
        white-space: nowrap;
        background: var(--color-accent);
        padding: 5px 12px;
        border-radius: 20px;
    }

    .selection-actions {
        display: flex;
        justify-content: center;
        gap: 10px;
    }

    .btn-clear {
        width: 44px;
        height: 44px;
        border-radius: 22px;
        border: 1.5px solid var(--color-border);
        background: white;
        color: var(--color-text-muted);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        transition: all 0.2s;
        flex-shrink: 0;
    }

    .btn-clear:hover {
        border-color: var(--color-error);
        color: var(--color-error);
        background: rgba(193, 68, 79, 0.05);
    }

    .btn-block {
        width: 44px;
        height: 44px;
        border-radius: 22px;
        border: 1.5px solid #EF4444;
        background: white;
        color: #EF4444;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 14px;
        transition: all 0.2s;
        flex-shrink: 0;
    }

    .btn-block:hover {
        background: #FEE2E2;
        border-color: #DC2626;
        color: #DC2626;
    }

    .btn-reserve {
        flex: 0 1 auto;
        min-width: 140px;
        padding: 12px 20px;
        background: linear-gradient(135deg, #D4AF37 0%, #B8960C 100%);
        color: white;
        font-weight: 600;
        font-size: 15px;
        border: none;
        border-radius: 12px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        transition: all 0.2s;
        box-shadow: 0 2px 8px rgba(212, 175, 55, 0.3);
    }

    .btn-reserve:hover {
        box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
    }

    .btn-reserve:active {
        transform: scale(0.98);
    }

    /* =============================================================================
   FURNITURE STYLING (Map)
   ============================================================================= */
    .furniture-item {
        transition: filter 0.2s, transform 0.2s;
        cursor: pointer;
    }

    .furniture-item:active {
        filter: brightness(0.9);
    }

    .furniture-item.selected {
        filter: drop-shadow(0 0 8px var(--color-primary));
    }

    .furniture-item.highlighted {
        animation: pulseHighlight 1s ease-in-out infinite;
    }

    @keyframes pulseHighlight {

        0%,
        100% {
            filter: drop-shadow(0 0 8px var(--color-primary));
        }

        50% {
            filter: drop-shadow(0 0 16px var(--color-primary));
        }
    }

    /* Decorative items */
    .decorative-item {
        pointer-events: none;
    }

    /* =============================================================================
   HIDDEN DATE PICKER
   ============================================================================= */
    .date-picker-hidden {
        position: absolute;
        opacity: 0;
        width: 0;
        height: 0;
        pointer-events: none;
    }

    .date-picker-hidden.show {
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        opacity: 1;
        width: auto;
        height: auto;
        pointer-events: auto;
        z-index: 200;
        background: white;
        padding: 8px;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }

    /* =============================================================================
   DESKTOP ENHANCEMENTS
   ============================================================================= */
    @media (min-width: 768px) {
        .map-toolbar {
            padding: 12px 24px;
        }

        .date-display {
            min-width: 120px;
            font-size: 15px;
        }

        .zone-selector-gold {
            min-width: 180px;
            font-size: 15px;
        }

        .zoom-fab {
            bottom: 120px;
            right: 24px;
        }

        /* Bottom bar accounts for sidebar */
        .bottom-action-bar {
            left: var(--sidebar-width, 280px);
        }
    }


    /* Hover states for desktop */
    @media (hover: hover) {
        .furniture-item:hover {
            filter: brightness(1.1);
        }

        .furniture-item:hover rect,
        .furniture-item:hover ellipse,
        .furniture-item:hover circle {
            stroke-width: 3;
        }
    }

    /* =============================================================================
   CONTEXT MENU (Keep from original)
   ============================================================================= */
    .context-menu {
        position: fixed;
        background: white;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        z-index: 1050;
        min-width: 180px;
        padding: 8px 0;
        border: 1px solid var(--color-border);
    }

    .context-menu-item {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 16px;
        cursor: pointer;
        transition: background 0.2s;
        color: var(--color-text);
        font-size: 14px;
    }

    .context-menu-item:hover {
        background: var(--color-accent);
    }

    .context-menu-item.danger {
        color: var(--color-danger);
    }

    .context-menu-item.danger:hover {
        background: #fef2f2;
    }

    .context-menu-divider {
        height: 1px;
        background: var(--color-border);
        margin: 6px 0;
    }

    .context-menu-header {
        padding: 8px 16px;
        font-size: 12px;
        color: var(--color-text-muted);
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    /* =============================================================================
       EXISTING RESERVATION HIGHLIGHT
       Pulsing red border for furniture when viewing existing reservation
       ============================================================================= */
    .furniture-item.existing-reservation-highlight rect,
    .furniture-item.existing-reservation-highlight circle,
    .furniture-item.existing-reservation-highlight ellipse {
        stroke: #C1444F !important;
        stroke-width: 4px !important;
        animation: pulse-border 1.5s ease-in-out infinite;
    }

    @keyframes pulse-border {
        0%, 100% {
            stroke-opacity: 1;
            stroke-width: 4px;
        }
        50% {
            stroke-opacity: 0.6;
            stroke-width: 6px;
        }
    }

    .furniture-item.existing-reservation-highlight {
        filter: drop-shadow(0 0 8px rgba(193, 68, 79, 0.6)) !important;
    }
</style>
{% endblock %}

{% block content %}
<div class="map-page">
    <!-- Compact Toolbar -->
    <div class="map-toolbar">
        <!-- Date Navigation -->
        <div class="toolbar-group">
            <button type="button" class="toolbar-btn" id="btn-prev-day" title="Dia anterior">
                <i class="fas fa-chevron-left"></i>
            </button>
            <span class="date-display" id="date-display" title="Seleccionar fecha">
                Cargando...
            </span>
            <button type="button" class="toolbar-btn" id="btn-next-day" title="Dia siguiente">
                <i class="fas fa-chevron-right"></i>
            </button>
        </div>

        <!-- Zone Selector -->
        <select class="zone-selector-gold" id="zone-select">
            <!-- Populated dynamically -->
        </select>

        <!-- Search & Filters -->
        <div class="toolbar-group search-filter-group">
            <div class="map-search-wrapper">
                <i class="fas fa-search map-search-icon"></i>
                <input type="text" id="map-search-input" class="map-search-input"
                       placeholder="Buscar..." autocomplete="off" aria-label="Buscar en el mapa">
                <button type="button" class="map-search-clear" id="map-search-clear" style="display:none;">
                    <i class="fas fa-times"></i>
                </button>
                <!-- Search Results -->
                <div class="map-search-results" id="map-search-results" role="listbox"></div>
            </div>
            <!-- Inline Filter Dropdowns -->
            <div class="map-filter-dropdowns">
                <select id="search-filter-state" class="map-filter-select" title="Filtrar por estado">
                    <option value="">Estado</option>
                </select>
                <select id="search-filter-type" class="map-filter-select" title="Filtrar por tipo de cliente">
                    <option value="">Tipo</option>
                    <option value="interno">Interno</option>
                    <option value="externo">Externo</option>
                </select>
                <select id="search-filter-paid" class="map-filter-select" title="Filtrar por estado de pago">
                    <option value="">Pago</option>
                    <option value="1">Pagado</option>
                    <option value="0">Sin pagar</option>
                </select>
                <button type="button" class="map-filter-clear" id="filter-clear-btn" title="Limpiar filtros" style="display:none;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
        </div>

        <!-- Add Temporary Furniture Button -->
        <button type="button" class="toolbar-btn" id="btn-add-temp-furniture" title="A√±adir mobiliario temporal">
            <i class="fas fa-plus-circle"></i>
        </button>

        <!-- Refresh Button -->
        <button type="button" class="toolbar-btn" id="btn-refresh" title="Actualizar">
            <i class="fas fa-sync-alt"></i>
        </button>

        <!-- Waitlist Button -->
        <button type="button" class="toolbar-btn waitlist-toolbar-btn" id="waitlistToolbarBtn"
                title="Lista de Espera" aria-label="Abrir lista de espera">
            <i class="fas fa-clock"></i>
            <span class="waitlist-badge" id="waitlistToolbarBadge" data-count="0"></span>
        </button>
    </div>

    <!-- Hidden Date Picker -->
    <input type="date" id="date-picker" class="date-picker-hidden">

    <!-- Stats Strip -->
    <div class="stats-strip">
        <div class="stat-item">
            <span class="stat-value" id="stat-total">-</span>
            <span class="stat-label">Total</span>
        </div>
        <div class="stat-item stat-available">
            <span class="stat-value" id="stat-available">-</span>
            <span class="stat-label">Disp</span>
        </div>
        <div class="stat-item stat-occupied">
            <span class="stat-value" id="stat-occupied">-</span>
            <span class="stat-label">Ocup</span>
        </div>
        <div class="stat-item">
            <span class="stat-value" id="stat-rate">-%</span>
            <span class="stat-label">Ocup</span>
        </div>
    </div>

    <!-- Canvas Info Bar (Map Editor Style) -->
    <div class="canvas-info-bar">
        <div class="info-group">
            <span class="info-label"><i class="fas fa-expand-arrows-alt"></i></span>
            <span class="info-value" id="canvas-dimensions">-</span>
        </div>
        <div class="info-divider"></div>
        <div class="info-group">
            <span class="info-label">Cursor:</span>
            <span class="info-value highlight" id="cursor-pos">-</span>
        </div>
        <div class="info-divider"></div>
        <div class="info-group">
            <span class="info-value" id="furniture-count">0</span>
            <span class="info-label">elementos</span>
        </div>
        <div class="info-spacer"></div>
        <div class="info-group zoom-controls">
            <button type="button" class="info-btn" id="btn-zoom-out-bar" title="Alejar (Ctrl+-)">
                <i class="fas fa-minus"></i>
            </button>
            <span class="info-value zoom-level" id="zoom-level">100%</span>
            <button type="button" class="info-btn" id="btn-zoom-in-bar" title="Acercar (Ctrl++)">
                <i class="fas fa-plus"></i>
            </button>
            <button type="button" class="info-btn" id="btn-zoom-reset" title="Reset a vista guardada (Ctrl+0)">
                <i class="fas fa-expand"></i>
            </button>
            <button type="button" class="info-btn" id="btn-save-view" title="Guardar vista actual">
                <i class="fas fa-save"></i>
            </button>
        </div>
        <div class="info-divider"></div>
        <div class="dropdown">
            <button type="button" class="info-btn" data-bs-toggle="dropdown" title="Atajos de teclado">
                <i class="fas fa-keyboard"></i>
            </button>
            <div class="dropdown-menu dropdown-menu-end shortcuts-dropdown p-3">
                <h6 class="dropdown-header px-0 mb-2"><i class="fas fa-keyboard me-2"></i>Atajos de Teclado</h6>
                <div class="shortcuts-section mb-3">
                    <div class="shortcuts-title">Seleccion</div>
                    <div class="shortcut-row"><kbd>Click</kbd> <span>Seleccionar/deseleccionar</span></div>
                    <div class="shortcut-row"><kbd>Ctrl</kbd> + <kbd>A</kbd> <span>Seleccionar todo</span></div>
                    <div class="shortcut-row"><kbd>Ctrl</kbd> + <kbd>F</kbd> <span>Buscar</span></div>
                    <div class="shortcut-row"><kbd>Esc</kbd> <span>Deseleccionar</span></div>
                </div>
                <div class="shortcuts-section mb-3">
                    <div class="shortcuts-title">Vista</div>
                    <div class="shortcut-row"><kbd>Shift</kbd> + <kbd>Rueda</kbd> <span>Zoom</span></div>
                    <div class="shortcut-row"><kbd>Ctrl</kbd> + <kbd>+</kbd> / <kbd>-</kbd> <span>Zoom in/out</span>
                    </div>
                    <div class="shortcut-row"><kbd>Ctrl</kbd> + <kbd>S</kbd> <span>Guardar vista</span></div>
                    <div class="shortcut-row"><kbd>Ctrl</kbd> + <kbd>0</kbd> <span>Restaurar vista</span></div>
                </div>
                <div class="shortcuts-section mb-3">
                    <div class="shortcuts-title">Navegacion</div>
                    <div class="shortcut-row"><kbd>Espacio</kbd> + <kbd>Arrastrar</kbd> <span>Pan del canvas</span>
                    </div>
                    <div class="shortcut-row"><kbd>Rueda central</kbd> + <kbd>Arrastrar</kbd> <span>Pan del
                            canvas</span></div>
                    <div class="shortcut-row"><kbd>&#8592;</kbd> / <kbd>&#8594;</kbd> <span>Dia
                            anterior/siguiente</span></div>
                </div>
                <div class="shortcuts-section">
                    <div class="shortcuts-title">Acciones</div>
                    <div class="shortcut-row"><kbd>R</kbd> <span>Actualizar mapa</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Map Canvas -->
    <div class="map-canvas-wrapper">
        <div class="map-canvas" id="map-container">
            <div class="map-loading">
                <div class="spinner-border text-primary mb-3" role="status">
                    <span class="visually-hidden">Cargando...</span>
                </div>
                <p>Cargando mapa...</p>
            </div>
        </div>
    </div>

    <!-- Floating Zoom Controls (outside scrollable area) -->
    <div class="zoom-fab">
        <button type="button" class="fab-btn" id="btn-zoom-in" title="Acercar">
            <i class="fas fa-plus"></i>
        </button>
        <button type="button" class="fab-btn" id="btn-zoom-out" title="Alejar">
            <i class="fas fa-minus"></i>
        </button>
    </div>
</div>

<!-- Bottom Action Bar (Slides up on selection) -->
<div class="bottom-action-bar" id="selection-bar">
    <div class="selection-summary">
        <div class="selected-items" id="selected-badges">
            <!-- Chips populated dynamically -->
        </div>
        <div class="selection-meta">
            <i class="fas fa-users"></i>
            <span id="total-capacity">0</span> pers
        </div>
    </div>
    <div class="selection-actions" id="selection-actions">
        <button type="button" class="btn-clear" id="btn-clear-selection" title="Limpiar seleccion">
            <i class="fas fa-times"></i>
        </button>
        <!-- Block selected furniture -->
        <button type="button" class="btn-block" id="btn-block-selection" title="Bloquear seleccionados">
            <i class="fas fa-ban"></i>
        </button>
        <!-- Action button changes based on selection type -->
        <button type="button" class="btn-reserve" id="btn-new-reservation">
            <i class="fas fa-calendar-plus"></i>
            <span>Reservar</span>
        </button>
    </div>
</div>

<!-- Conflict Resolution Instruction Panel -->
<div id="conflictInstructionPanel" class="conflict-instruction-panel" style="display: none;">
    <div class="conflict-instruction-header">
        <i class="fas fa-info-circle"></i>
        <span>Resoluci√≥n de Conflicto</span>
    </div>
    <div class="conflict-instruction-body">
        <p id="conflictInstructionText">Selecciona hamacas alternativas</p>
        <div class="conflict-selection-counter">
            Seleccionados: <strong id="conflictSelectedCount">0</strong> /
            Requeridos: <strong id="conflictRequiredCount">0</strong>
        </div>
        <div id="conflictReplacingList" class="conflict-replacing-list"></div>
    </div>
</div>

<!-- Quick Swap Modal - Move blocking reservation to free up furniture -->
<div id="quickSwapModal" class="quick-swap-modal" style="display: none;">
    <div class="quick-swap-backdrop"></div>
    <div class="quick-swap-content">
        <div class="quick-swap-header">
            <i class="fas fa-exchange-alt"></i>
            <span>Mover Reserva</span>
        </div>
        <div class="quick-swap-body">
            <p id="quickSwapMessage">Esta hamaca est√° ocupada.</p>
            <div class="quick-swap-reservation-info">
                <div class="quick-swap-customer">
                    <i class="fas fa-user"></i>
                    <span id="quickSwapCustomerName">Cliente</span>
                </div>
                <div class="quick-swap-furniture">
                    <i class="fas fa-umbrella-beach"></i>
                    <span id="quickSwapFurnitureLabel">H1</span>
                </div>
            </div>
            <p class="quick-swap-instruction">
                ¬øDeseas mover esta reserva a otra hamaca libre?
            </p>
            <div id="quickSwapSelectPrompt" style="display: none;">
                <p class="text-warning">
                    <i class="fas fa-hand-pointer"></i>
                    Selecciona una hamaca disponible en el mapa
                </p>
            </div>
        </div>
        <div class="quick-swap-footer">
            <button type="button" class="btn btn-outline-secondary" id="quickSwapCancelBtn">
                Cancelar
            </button>
            <button type="button" class="btn btn-warning" id="quickSwapStartBtn">
                <i class="fas fa-arrows-alt me-1"></i>
                Mover Reserva
            </button>
        </div>
    </div>
</div>

<!-- Context Menu -->
<div class="context-menu d-none" id="contextMenu">
    <div class="context-menu-header" id="context-menu-header">Hamaca #1</div>

    <!-- Available furniture menu items -->
    <div id="context-menu-available">
        <div class="context-menu-item" data-action="view-details">
            <i class="fas fa-info-circle"></i> Ver detalles
        </div>
        <div class="context-menu-item" data-action="select">
            <i class="fas fa-check-square"></i> Seleccionar
        </div>
        <div class="context-menu-item" data-action="new-reservation">
            <i class="fas fa-plus"></i> Nueva reserva
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="block">
            <i class="fas fa-ban"></i> Bloquear
        </div>
    </div>

    <!-- Occupied furniture menu items -->
    <div id="context-menu-occupied" class="d-none">
        <div class="context-menu-item" data-action="view-details">
            <i class="fas fa-info-circle"></i> Ver detalles
        </div>
        <div class="context-menu-item" data-action="view-reservation">
            <i class="fas fa-eye"></i> Ver reserva
        </div>
        <div class="context-menu-item" data-action="edit-reservation">
            <i class="fas fa-edit"></i> Editar reserva
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" data-action="cancel-reservation">
            <i class="fas fa-times"></i> Cancelar reserva
        </div>
    </div>
</div>

<!-- Reservation Panel (slide-in side panel for editing) -->
{% include 'beach/_reservation_panel.html' %}
{% include 'beach/_new_reservation_panel.html' %}

<!-- Block Furniture Modal -->
<div class="modal fade" id="block-furniture-modal" tabindex="-1" aria-labelledby="block-furniture-modal-label" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="block-furniture-modal-label">
                    <i class="fas fa-ban me-2"></i>Bloquear Mobiliario
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Cerrar"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label fw-semibold">Mobiliario a bloquear</label>
                    <div id="block-furniture-list" class="block-furniture-badges"></div>
                </div>
                <div class="mb-3">
                    <label for="block-type" class="form-label">Tipo de Bloqueo</label>
                    <select id="block-type" class="form-select">
                        <option value="maintenance">üîß Mantenimiento</option>
                        <option value="vip_hold">‚≠ê Reserva VIP</option>
                        <option value="event">üìÖ Evento</option>
                        <option value="other">üö´ Otro</option>
                    </select>
                </div>
                <div class="row mb-3">
                    <div class="col-6">
                        <label for="block-start-date" class="form-label">Fecha Inicio</label>
                        <input type="date" id="block-start-date" class="form-control">
                    </div>
                    <div class="col-6">
                        <label for="block-end-date" class="form-label">Fecha Fin <small class="text-muted">(opcional)</small></label>
                        <input type="date" id="block-end-date" class="form-control">
                    </div>
                </div>
                <div class="mb-3">
                    <label for="block-reason" class="form-label">Motivo <small class="text-muted">(opcional)</small></label>
                    <input type="text" id="block-reason" class="form-control" placeholder="Ej: Reparacion de sombrilla">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-danger" id="confirm-block-btn">
                    <i class="fas fa-ban me-1"></i>Bloquear
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Unblock Furniture Modal -->
<div class="modal fade" id="unblock-furniture-modal" tabindex="-1" aria-labelledby="unblock-furniture-modal-label" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header unblock-modal-header">
                <h5 class="modal-title" id="unblock-furniture-modal-label">
                    <i class="fas fa-lock-open me-2"></i>Desbloquear Mobiliario
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Cerrar"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label fw-semibold">Mobiliario</label>
                    <div id="unblock-furniture-number" class="fs-5 fw-bold text-primary"></div>
                </div>
                <div class="mb-3 p-3 bg-light rounded">
                    <label class="form-label fw-semibold mb-2">Bloqueo Actual</label>
                    <div class="small">
                        <div><strong>Tipo:</strong> <span id="unblock-block-type"></span></div>
                        <div><strong>Desde:</strong> <span id="unblock-block-start"></span></div>
                        <div><strong>Hasta:</strong> <span id="unblock-block-end"></span></div>
                        <div id="unblock-block-reason-row"><strong>Motivo:</strong> <span id="unblock-block-reason"></span></div>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label fw-semibold">Tipo de Desbloqueo</label>
                    <div class="form-check mb-2">
                        <input class="form-check-input" type="radio" name="unblock-type" id="unblock-type-full" value="full" checked>
                        <label class="form-check-label" for="unblock-type-full">
                            <strong>Desbloquear completamente</strong>
                            <div class="small text-muted">Elimina todo el bloqueo</div>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="unblock-type" id="unblock-type-partial" value="partial">
                        <label class="form-check-label" for="unblock-type-partial">
                            <strong>Desbloquear por fecha</strong>
                            <div class="small text-muted">Desbloquear solo un dia o rango de fechas</div>
                        </label>
                    </div>
                </div>
                <div id="unblock-date-range" class="row mb-3" style="display: none;">
                    <div class="col-6">
                        <label for="unblock-start-date" class="form-label">Fecha Inicio</label>
                        <input type="date" id="unblock-start-date" class="form-control">
                    </div>
                    <div class="col-6">
                        <label for="unblock-end-date" class="form-label">Fecha Fin</label>
                        <input type="date" id="unblock-end-date" class="form-control">
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-primary" id="confirm-unblock-btn">
                    <i class="fas fa-lock-open me-1"></i>Desbloquear
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Create Temporary Furniture Modal -->
<div class="modal fade" id="temp-furniture-modal" tabindex="-1" aria-labelledby="temp-furniture-modal-label" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="temp-furniture-modal-label">
                    <i class="fas fa-plus-circle me-2"></i>A√±adir Mobiliario Temporal
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Cerrar"></button>
            </div>
            <div class="modal-body">
                <div class="row mb-3">
                    <div class="col-6">
                        <label for="temp-zone" class="form-label">Zona <span class="text-danger">*</span></label>
                        <select id="temp-zone" class="form-select" required>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                    <div class="col-6">
                        <label for="temp-furniture-type" class="form-label">Tipo <span class="text-danger">*</span></label>
                        <select id="temp-furniture-type" class="form-select" required>
                            <!-- Populated dynamically -->
                        </select>
                    </div>
                </div>
                <div class="row mb-3">
                    <div class="col-4">
                        <label for="temp-number" class="form-label">Numero</label>
                        <input type="text" id="temp-number" class="form-control" placeholder="Auto">
                        <div class="form-text">Auto-generar</div>
                    </div>
                    <div class="col-4">
                        <label for="temp-capacity" class="form-label">Capacidad</label>
                        <input type="number" id="temp-capacity" class="form-control" value="2" min="1" max="10">
                    </div>
                    <div class="col-4">
                        <label for="temp-orientation" class="form-label">Orientacion</label>
                        <select id="temp-orientation" class="form-select">
                            <option value="0">Horizontal</option>
                            <option value="90">Vertical</option>
                        </select>
                    </div>
                </div>
                <div class="row mb-3">
                    <div class="col-6">
                        <label for="temp-start-date" class="form-label">Fecha Inicio <span class="text-danger">*</span></label>
                        <input type="date" id="temp-start-date" class="form-control" required>
                    </div>
                    <div class="col-6">
                        <label for="temp-end-date" class="form-label">Fecha Fin</label>
                        <input type="date" id="temp-end-date" class="form-control">
                        <div class="form-text">Opcional, si es solo un dia</div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-primary" id="confirm-temp-create-btn">
                    <i class="fas fa-plus me-1"></i>Crear
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Delete Temporary Furniture Modal -->
<div class="modal fade" id="delete-temp-modal" tabindex="-1" aria-labelledby="delete-temp-modal-label" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header delete-temp-modal-header">
                <h5 class="modal-title" id="delete-temp-modal-label">
                    <i class="fas fa-trash me-2"></i>Eliminar Mobiliario Temporal
                </h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Cerrar"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label fw-semibold">Mobiliario</label>
                    <div id="delete-temp-number" class="fs-5 fw-bold text-primary">T1</div>
                </div>
                <div class="mb-3 p-3 bg-light rounded">
                    <label class="form-label fw-semibold mb-2">Periodo de Validez</label>
                    <div class="small">
                        <div><strong>Desde:</strong> <span id="delete-temp-start"></span></div>
                        <div><strong>Hasta:</strong> <span id="delete-temp-end"></span></div>
                    </div>
                </div>
                <!-- Delete options (shown for multi-day) -->
                <div id="delete-temp-options" class="mb-3" style="display: none;">
                    <label class="form-label fw-semibold">Tipo de Eliminacion</label>
                    <div class="form-check mb-2">
                        <input class="form-check-input" type="radio" name="deleteType" id="delete-day-only" value="day" checked>
                        <label class="form-check-label" for="delete-day-only">
                            <strong>Eliminar solo este dia</strong>
                            <div class="small text-muted">Elimina el mobiliario solo para <span id="delete-temp-current-date"></span></div>
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="radio" name="deleteType" id="delete-all-days" value="all">
                        <label class="form-check-label" for="delete-all-days">
                            <strong>Eliminar completamente</strong>
                            <div class="small text-muted">Elimina el mobiliario para todas las fechas</div>
                        </label>
                    </div>
                </div>
                <!-- Single day message (shown for single-day) -->
                <div id="delete-temp-single-day-msg" class="mb-3">
                    <div class="alert alert-warning mb-0 py-2">
                        <i class="fas fa-exclamation-triangle me-2"></i>Esta accion no se puede deshacer.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancelar</button>
                <button type="button" class="btn btn-danger" id="confirm-temp-delete-btn">
                    <i class="fas fa-trash me-1"></i>Eliminar
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Waitlist Panel -->
{% include 'beach/_waitlist_panel.html' %}
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/customer-search.js') }}"></script>
<script src="{{ url_for('static', filename='js/date-picker.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/touch-handler.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/reservation-panel.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/safeguard-modal.js') }}"></script>
<script src="{{ url_for('static', filename='js/conflict-resolution-modal.js') }}"></script>
<!-- NewReservationPanel modules (must be loaded in dependency order) -->
<script src="{{ url_for('static', filename='js/map/reservation-panel/customer-handler.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/reservation-panel/date-availability.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/reservation-panel/pricing-calculator.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/reservation-panel/conflict-resolver.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/reservation-panel/safeguard-checks.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/reservation-panel/panel-core.js') }}"></script>
<script src="{{ url_for('static', filename='js/map/new-reservation-panel.js') }}"></script>
<script src="{{ url_for('static', filename='js/WaitlistManager.js') }}"></script>
<script type="module" src="{{ url_for('static', filename='js/map/index.js') }}"></script>
<script type="module">
    import { SearchManager } from '{{ url_for("static", filename="js/map/SearchManager.js") }}';
    import { BlockManager } from '{{ url_for("static", filename="js/map/block-manager.js") }}';
    import { TempFurnitureManager } from '{{ url_for("static", filename="js/map/temp-furniture-manager.js") }}';

    document.addEventListener('DOMContentLoaded', function () {
        // ==========================================================================
        // INITIALIZE MAP
        // ==========================================================================
        const map = new BeachMap('map-container', {
            apiUrl: '/beach/api/map/data',
            initialDate: new Date().toISOString().split('T')[0],
            enableZoom: true
        });

        // ==========================================================================
        // BLOCK MANAGER (Furniture blocking functionality)
        // ==========================================================================
        const blockManager = new BlockManager({
            getCurrentDate: () => map.getCurrentDate(),
            onBlockSuccess: () => map.loadData(),
            onUnblockSuccess: () => map.loadData(),
            getBlockInfo: (furnitureId) => {
                const data = map.getData();
                return data?.blocks?.[furnitureId] || null;
            }
        });

        // Wire up BeachMap block/unblock callbacks
        map.on('onBlockRequest', (furnitureIds, furnitureNumbers) => {
            blockManager.showBlockModal(furnitureIds, furnitureNumbers);
        });

        map.on('onUnblockRequest', (furnitureId, furnitureNumber) => {
            const data = map.getData();
            const blockInfo = data?.blocks?.[furnitureId] || null;
            blockManager.showUnblockModal(furnitureId, furnitureNumber, blockInfo);
        });

        // ==========================================================================
        // TEMP FURNITURE MANAGER (Add/delete temporary furniture)
        // ==========================================================================
        const tempFurnitureManager = new TempFurnitureManager({
            getCurrentDate: () => map.getCurrentDate(),
            getZones: () => map.getData()?.zones || [],
            getFurnitureTypes: () => map.getData()?.furniture_types || {},
            onCreateSuccess: () => map.loadData(),
            onDeleteSuccess: () => map.loadData()
        });

        // Wire up temp furniture callbacks
        map.on('onAddTemporaryRequest', (x, y, zoneId) => {
            tempFurnitureManager.showCreateModal(x, y, zoneId);
        });

        map.on('onDeleteTemporaryRequest', (furnitureId, furnitureNumber) => {
            tempFurnitureManager.showDeleteModal(furnitureId, furnitureNumber);
        });

        // Toolbar button handler
        const addTempBtn = document.getElementById('btn-add-temp-furniture');
        if (addTempBtn) {
            addTempBtn.addEventListener('click', () => {
                // Open modal with default position (will be in first zone)
                const zones = map.getData()?.zones || [];
                const firstZoneId = zones.length > 0 ? zones[0].id : null;
                tempFurnitureManager.showCreateModal(100, 100, firstZoneId);
            });
        }

        // ==========================================================================
        // WAITLIST MANAGER (Waitlist panel functionality)
        // ==========================================================================
        const waitlistManager = new WaitlistManager({
            currentDate: map.getCurrentDate(),
            onConvert: (entry) => {
                // Open new reservation panel with pre-filled data from waitlist entry
                // This will be fully implemented in Task 9
                console.log('Convert waitlist entry:', entry);

                // For now, dispatch event for future handling
                document.dispatchEvent(new CustomEvent('waitlist:convertToReservation', {
                    detail: { entry }
                }));
            }
        });

        // Toolbar button click handler
        document.getElementById('waitlistToolbarBtn')?.addEventListener('click', () => {
            waitlistManager.open();
        });

        // Function to update waitlist badge
        function updateWaitlistBadge() {
            waitlistManager.setDate(map.getCurrentDate());
            const badge = document.getElementById('waitlistToolbarBadge');
            if (badge) {
                // Fetch current count from API
                fetch(`/beach/api/waitlist/count?date=${map.getCurrentDate()}`)
                    .then(response => response.json())
                    .then(data => {
                        const count = data.count || 0;
                        badge.textContent = count > 0 ? count : '';
                        badge.dataset.count = count;
                    })
                    .catch(err => console.error('Error fetching waitlist count:', err));
            }
        }

        // Listen for waitlist count updates
        window.addEventListener('waitlist:countUpdate', updateWaitlistBadge);

        // Update badge when date changes
        map.on('onDateChange', () => {
            updateWaitlistBadge();
        });

        // Initial badge update after short delay for map to load
        setTimeout(updateWaitlistBadge, 500);

        // ==========================================================================
        // SEARCH MANAGER (Enhanced with filters and grouped results)
        // ==========================================================================
        const searchManager = new SearchManager();

        // Load search reservations when map renders
        map.on('onRender', (data) => {
            const zoneId = document.getElementById('zone-select')?.value || null;
            searchManager.loadReservations(map.getCurrentDate(), zoneId ? parseInt(zoneId) : null);
        });

        // Also load initial data after a short delay
        setTimeout(() => {
            const zoneId = document.getElementById('zone-select')?.value || null;
            searchManager.loadReservations(map.getCurrentDate(), zoneId ? parseInt(zoneId) : null);
        }, 500);

        // Handle search result selection (active reservations)
        searchManager.on('onSelect', (result) => {
            // Highlight ALL furniture for this reservation
            if (result.furnitureIds && result.furnitureIds.length > 0) {
                // Highlight first furniture and pan to it
                map.highlightAndPanToFurniture(result.furnitureIds[0]);
                // Highlight additional furniture items
                result.furnitureIds.slice(1).forEach(id => {
                    const el = document.querySelector(`[data-furniture-id="${id}"]`);
                    if (el) el.classList.add('search-highlight');
                });
            }

            // Open reservation panel
            if (result.reservationId) {
                openReservationPanel(result.reservationId, 'view');
            }
        });

        // Handle navigation for released reservations
        searchManager.on('onNavigate', (reservationId) => {
            window.location.href = `/beach/reservations/${reservationId}`;
        });

        // Filter event listeners
        const filterStateSelect = document.getElementById('search-filter-state');
        const filterTypeSelect = document.getElementById('search-filter-type');
        const filterPaidSelect = document.getElementById('search-filter-paid');
        const filterClearBtn = document.getElementById('filter-clear-btn');

        // Function to update filter dropdown active states and clear button visibility
        function updateFilterUI() {
            const hasFilters = filterStateSelect?.value || filterTypeSelect?.value || filterPaidSelect?.value;

            // Toggle active class on dropdowns
            filterStateSelect?.classList.toggle('active', !!filterStateSelect.value);
            filterTypeSelect?.classList.toggle('active', !!filterTypeSelect.value);
            filterPaidSelect?.classList.toggle('active', !!filterPaidSelect.value);

            // Show/hide clear button
            if (filterClearBtn) {
                filterClearBtn.style.display = hasFilters ? 'flex' : 'none';
            }
        }

        if (filterStateSelect) {
            filterStateSelect.addEventListener('change', (e) => {
                searchManager.setFilter('state', e.target.value || null);
                updateFilterUI();
            });
        }
        if (filterTypeSelect) {
            filterTypeSelect.addEventListener('change', (e) => {
                searchManager.setFilter('customerType', e.target.value || null);
                updateFilterUI();
            });
        }
        if (filterPaidSelect) {
            filterPaidSelect.addEventListener('change', (e) => {
                const val = e.target.value;
                searchManager.setFilter('paid', val === '' ? null : val === '1');
                updateFilterUI();
            });
        }
        if (filterClearBtn) {
            filterClearBtn.addEventListener('click', () => {
                searchManager.clearFilters();
                // Reset dropdown values
                if (filterStateSelect) filterStateSelect.value = '';
                if (filterTypeSelect) filterTypeSelect.value = '';
                if (filterPaidSelect) filterPaidSelect.value = '';
                updateFilterUI();
            });
        }

        // Reload search data when zone changes
        document.getElementById('zone-select')?.addEventListener('change', () => {
            const zoneId = document.getElementById('zone-select')?.value || null;
            searchManager.loadReservations(map.getCurrentDate(), zoneId ? parseInt(zoneId) : null);
        });

        // Add global keyboard listener for search shortcut (Ctrl+F or /)
        document.addEventListener('keydown', (e) => {
            const isInputField = ['input', 'textarea', 'select'].includes(e.target.tagName.toLowerCase());
            if (!isInputField) {
                if ((e.ctrlKey && e.key === 'f') || e.key === '/') {
                    e.preventDefault();
                    searchManager.focus();
                }
            }
        });

        // ==========================================================================
        // RESERVATION PANEL (Slide-in for editing)
        // ==========================================================================
        const reservationPanel = new ReservationPanel({
            apiBaseUrl: '/beach/api',
            onClose: () => {
                // Refresh map when panel closes
                map.refreshAvailability();
                updateStats(currentZoneId);
            },
            onStateChange: (reservationId, newState) => {
                // Refresh map after state change
                map.refreshAvailability();
                updateStats(currentZoneId);
            },
            onSave: (reservationId, updates) => {
                // Refresh map after save
                map.refreshAvailability();
                updateStats(currentZoneId);
            },
            onFurnitureReassign: (reservationId, furniture, numPeople, action) => {
                // Handle panel's reassignment mode signals
                if (action === 'enter') {
                    enterPanelReassignmentMode(reservationId, furniture, numPeople);
                } else if (action === 'exit') {
                    exitPanelReassignmentMode();
                }
            },
            onCustomerChange: (reservationId, customer) => {
                // Refresh map after customer change
                map.refreshAvailability();
            }
        });

        // Function to open the reservation panel
        function openReservationPanel(reservationId, mode = 'view') {
            const currentDate = map.getCurrentDate();
            reservationPanel.setMapData(map.getData());
            reservationPanel.open(reservationId, currentDate, mode);
        }

        // ==========================================================================
        // FURNITURE SELECT MODE (from standalone panel navigation)
        // When user clicks "Cambiar mobiliario" from reservations list page
        // ==========================================================================
        function checkFurnitureSelectMode() {
            const params = new URLSearchParams(window.location.search);
            const mode = params.get('mode');
            const reservationId = params.get('reservation_id');
            const returnUrl = params.get('return_url');
            const date = params.get('date');

            if (mode === 'furniture_select' && reservationId) {
                // Store return URL for after save
                window.furnitureSelectReturnUrl = returnUrl ? decodeURIComponent(returnUrl) : '/beach/reservations';

                // Set the date if provided
                if (date) {
                    map.setCurrentDate(date);
                }

                // Wait for map data to load, then open panel in reassignment mode
                setTimeout(() => {
                    const currentDate = date || map.getCurrentDate();
                    reservationPanel.setMapData(map.getData());
                    reservationPanel.open(parseInt(reservationId), currentDate, 'edit');

                    // Wait for panel data to load, then enter reassignment mode
                    function waitForDataAndEnterReassignment(attempts = 0) {
                        if (attempts > 20) {
                            console.error('Failed to enter reassignment mode - data not loaded');
                            return;
                        }

                        // Check if reservation data is loaded
                        if (reservationPanel.state.data?.reservation) {
                            reservationPanel.enterReassignmentMode();
                            showFurnitureSelectBanner();
                        } else {
                            // Try again in 200ms
                            setTimeout(() => waitForDataAndEnterReassignment(attempts + 1), 200);
                        }
                    }

                    // Start checking after initial delay
                    setTimeout(() => waitForDataAndEnterReassignment(), 500);
                }, 1000);

                // Add a visual banner for furniture select mode
                function showFurnitureSelectBanner() {
                    let banner = document.getElementById('furnitureSelectBanner');
                    if (!banner) {
                        banner = document.createElement('div');
                        banner.id = 'furnitureSelectBanner';
                        banner.style.cssText = `
                            position: fixed;
                            top: calc(var(--space-4, 16px) + 54px);
                            left: 50%;
                            transform: translateX(-50%);
                            max-width: calc(100vw - var(--space-8, 32px));
                            background: linear-gradient(135deg, var(--color-primary) 0%, var(--color-primary-dark) 100%);
                            color: white;
                            padding: var(--space-3, 12px) var(--space-6, 24px);
                            border-radius: var(--border-radius-md, 8px);
                            box-shadow: var(--shadow-lg, 0 10px 15px rgba(0, 0, 0, 0.1));
                            z-index: var(--z-toast, 500);
                            font-weight: 600;
                            display: flex;
                            align-items: center;
                            gap: var(--space-3, 12px);
                        `;
                        banner.innerHTML = `
                            <i class="fas fa-hand-pointer"></i>
                            <span>Haz clic en el mobiliario del mapa para seleccionarlo</span>
                            <button onclick="this.parentElement.remove()"
                                    aria-label="Cerrar"
                                    style="background:none;border:none;color:white;cursor:pointer;margin-left:var(--space-2, 8px);padding:var(--space-1, 4px);">
                                <i class="fas fa-times"></i>
                            </button>
                        `;
                        document.body.appendChild(banner);

                        // Auto-hide after 5 seconds
                        setTimeout(() => banner.remove(), 5000);
                    }
                }
            }
        }

        // Override onSave to handle furniture select mode return
        const originalOnSave = reservationPanel.options.onSave;
        reservationPanel.options.onSave = (reservationId, updates) => {
            // Call original handler
            if (originalOnSave) {
                originalOnSave(reservationId, updates);
            }

            // If in furniture select mode, redirect back to reservations
            if (window.furnitureSelectReturnUrl) {
                const returnUrl = window.furnitureSelectReturnUrl;
                window.furnitureSelectReturnUrl = null;

                // Add success message param
                const url = new URL(returnUrl, window.location.origin);
                url.searchParams.set('furniture_updated', '1');

                window.location.href = url.toString();
            }
        };

        // Check for furniture select mode on page load
        // Call directly since we're already inside DOMContentLoaded
        checkFurnitureSelectMode();

        // ==========================================================================
        // NEW RESERVATION PANEL (Slide-in for creating)
        // ==========================================================================
        const newReservationPanel = new NewReservationPanel({
            apiBaseUrl: '/beach/api',
            onSave: (reservation) => {
                // Refresh map after creating reservation
                map.refreshAvailability();
                map.clearSelection();
                updateSelectionBar();
                updateStats(currentZoneId);
            },
            onCancel: () => {
                // Keep selection on cancel so user can try again
            }
        });

        // Function to open the new reservation panel
        function openNewReservationPanel() {
            const selected = map.getSelectedFurnitureData();
            if (selected.length === 0) {
                if (window.PuroBeach && window.PuroBeach.showToast) {
                    window.PuroBeach.showToast('Selecciona mobiliario primero', 'warning');
                }
                return;
            }
            const currentDate = map.getCurrentDate();
            newReservationPanel.open(selected, currentDate);
        }

        // ==========================================================================
        // ADD MORE FURNITURE MODE (from capacity warning in new reservation panel)
        // ==========================================================================
        let addMoreFurnitureContext = null;

        // Listen for request to add more furniture
        document.addEventListener('reservation:addMoreFurniture', (e) => {
            const { currentFurniture, neededCapacity, currentDate } = e.detail;

            // Store context for when user confirms selection
            addMoreFurnitureContext = {
                currentFurniture: currentFurniture,
                neededCapacity: neededCapacity,
                date: currentDate
            };

            // Clear any existing selection
            map.clearSelection();

            // Pre-select the furniture that was already selected in the panel
            currentFurniture.forEach(id => {
                map.selectFurniture(id, true);
            });

            updateSelectionBar();

            // Show toast with instructions
            if (window.PuroBeach && window.PuroBeach.showToast) {
                window.PuroBeach.showToast(`Selecciona ${neededCapacity} mobiliario(s) adicional(es) y pulsa "Reservar"`, 'info', 5000);
            }
        });

        // Override the openNewReservationPanel to handle add furniture mode
        const originalOpenNewReservationPanel = openNewReservationPanel;
        openNewReservationPanel = function() {
            if (addMoreFurnitureContext) {
                // In add furniture mode - send selected furniture back to panel
                const selected = map.getSelectedFurnitureData();
                const newFurniture = selected.filter(f => !addMoreFurnitureContext.currentFurniture.includes(f.id));

                if (newFurniture.length > 0) {
                    // Add the new furniture to the reservation panel
                    newReservationPanel.addFurniture(newFurniture);
                } else {
                    // Just restore the panel
                    newReservationPanel.panel.classList.remove('minimized');
                    newReservationPanel.backdrop.classList.add('show');
                }

                // Clear the context but keep furniture selected on map
                addMoreFurnitureContext = null;

                // Update map selection to show all furniture in the panel
                const allPanelFurniture = newReservationPanel.state.selectedFurniture.map(f => f.id);
                map.clearSelection();
                allPanelFurniture.forEach(id => {
                    map.selectFurniture(id, true);
                });
                updateSelectionBar();
            } else {
                // Normal behavior
                originalOpenNewReservationPanel();
            }
        };

        // ==========================================================================
        // CONFLICT RESOLUTION - Alternative selection from map
        // ==========================================================================
        let conflictResolutionContext = null;

        // Listen for request to select alternative furniture
        document.addEventListener('conflictResolution:selectAlternative', (e) => {
            const { date, conflicts, currentSelection, originalCount, conflictingLabels } = e.detail;

            // Store context for when user confirms selection
            // requiredCount = total furniture originally selected (for contiguity)
            conflictResolutionContext = {
                date: date,
                conflicts: conflicts,
                originalSelection: currentSelection,
                requiredCount: originalCount || currentSelection.length,
                conflictingLabels: conflictingLabels
            };

            // Hide the panel backdrop to ensure map is fully interactive
            const backdrop = document.getElementById('newReservationPanelBackdrop');
            if (backdrop) {
                backdrop.classList.remove('show');
            }

            // Clear any existing selection so user starts fresh
            map.clearSelection();
            updateSelectionBar();

            // Navigate map to the conflict date
            if (date !== map.getCurrentDate()) {
                map.goToDate(date).then(() => {
                    // Ensure selection is cleared after map loads
                    map.clearSelection();
                    updateSelectionBar();

                    // Highlight after map loads
                    highlightConflictingFurniture(conflicts);
                    updateConflictSelectionCounter();
                });
            } else {
                highlightConflictingFurniture(conflicts);
            }

            // Update selection bar to show conflict resolution mode
            updateSelectionBarForConflict();

            // Show instruction panel with conflicting furniture labels
            showConflictInstructions(conflicts, conflictResolutionContext.requiredCount, conflictingLabels);
        });

        // Highlight conflicting furniture on the map
        function highlightConflictingFurniture(conflicts) {
            // Clear any existing highlights first
            clearConflictHighlights();

            // Apply highlight to each conflicting furniture
            conflicts.forEach(conflict => {
                const el = document.querySelector(
                    `.furniture-item[data-furniture-id="${conflict.furniture_id}"]`
                );
                if (el) {
                    el.classList.add('conflict-blocked');
                }
            });
        }

        // Clear conflict highlights
        function clearConflictHighlights() {
            document.querySelectorAll('.furniture-item.conflict-blocked').forEach(el => {
                el.classList.remove('conflict-blocked');
            });
        }

        // Show conflict instruction panel
        function showConflictInstructions(conflicts, requiredCount, conflictingLabels) {
            const panel = document.getElementById('conflictInstructionPanel');

            // Get conflicting furniture labels
            const labels = conflictingLabels ||
                conflicts.map(c => c.furniture_number || `#${c.furniture_id}`).join(', ');

            // Update counters
            document.getElementById('conflictRequiredCount').textContent = requiredCount;
            document.getElementById('conflictSelectedCount').textContent = map.getSelectedFurniture().length;

            // Check if all conflicts are resolved
            if (!conflicts || conflicts.length === 0) {
                document.getElementById('conflictInstructionText').innerHTML =
                    `<i class="fas fa-check-circle text-success"></i> Conflicto resuelto<br>` +
                    `Selecciona ${requiredCount} hamaca(s)`;
                document.getElementById('conflictReplacingList').innerHTML =
                    `<small>La hamaca original ya est√° disponible</small>`;
            } else {
                // Build detailed conflict info
                let conflictDetails = '';
                conflicts.forEach(c => {
                    const blockerInfo = c.room_number
                        ? `Hab. ${c.room_number} (${c.customer_name})`
                        : c.customer_name;

                    conflictDetails += `<div class="mb-1">
                        <strong>${c.furniture_number || '#' + c.furniture_id}</strong>: 
                        <span class="text-danger">${blockerInfo}</span>
                    </div>`;
                });

                // Update instruction text to show which furniture has conflict
                document.getElementById('conflictInstructionText').innerHTML =
                    `<div class="mb-2">${conflictDetails}</div>` +
                    `Selecciona ${requiredCount} hamaca(s) alternativa(s)`;

                // Show tip about clicking conflicting furniture
                document.getElementById('conflictReplacingList').innerHTML =
                    `<small><i class="fas fa-lightbulb text-warning"></i> ` +
                    `Haz clic en la hamaca ocupada para moverla</small>`;
            }

            panel.style.display = 'block';
        }

        // Hide conflict instruction panel
        function hideConflictInstructions() {
            const panel = document.getElementById('conflictInstructionPanel');
            if (panel) {
                panel.style.display = 'none';
            }
        }

        // Update selection counter for conflict resolution
        function updateConflictSelectionCounter() {
            if (!conflictResolutionContext) return;
            const selectedCount = map.getSelectedFurniture().length;
            const counterEl = document.getElementById('conflictSelectedCount');
            if (counterEl) {
                counterEl.textContent = selectedCount;
            }
            updateSelectionBarForConflict();
        }

        // Listen for request to open existing reservation (from safeguard duplicate check)
        document.addEventListener('reservation:openExisting', async (e) => {
            const { reservationId } = e.detail;
            if (reservationId) {
                openReservationPanel(reservationId, 'view');

                // Also select the reservation's furniture on the map with visual highlight
                try {
                    const currentDate = map.getCurrentDate();
                    const response = await fetch(`/beach/api/map/reservations/${reservationId}/details?date=${currentDate}`);
                    if (response.ok) {
                        const data = await response.json();
                        const furniture = data.reservation?.furniture || [];

                        // Filter furniture for current date
                        const todayFurniture = furniture.filter(f => {
                            if (!f.assignment_date) return true;
                            // Parse date properly (handles both ISO and RFC formats)
                            const dateObj = new Date(f.assignment_date);
                            const assignDate = dateObj.toISOString().split('T')[0];
                            return assignDate === currentDate;
                        });

                        // Select furniture on map and add highlight
                        if (todayFurniture.length > 0) {
                            // Clear any existing highlights first
                            document.querySelectorAll('.existing-reservation-highlight').forEach(el => {
                                el.classList.remove('existing-reservation-highlight');
                            });

                            // Get furniture IDs
                            const furnitureIds = todayFurniture.map(f => f.furniture_id || f.id);

                            // Select furniture on map
                            map.clearSelection();
                            furnitureIds.forEach(id => {
                                map.selectFurniture(id, true);
                            });
                            updateSelectionBar();

                            // Wait for map to re-render, then add highlight class
                            requestAnimationFrame(() => {
                                setTimeout(() => {
                                    furnitureIds.forEach(id => {
                                        const furnitureEl = document.querySelector(`g.furniture-item[data-furniture-id="${id}"]`);
                                        if (furnitureEl) {
                                            furnitureEl.classList.add('existing-reservation-highlight');
                                        }
                                    });

                                    // Remove highlight after 5 seconds
                                    setTimeout(() => {
                                        document.querySelectorAll('.existing-reservation-highlight').forEach(el => {
                                            el.classList.remove('existing-reservation-highlight');
                                        });
                                    }, 5000);
                                }, 200);
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error selecting reservation furniture on map:', error);
                }
            }
        });

        // Update selection bar for conflict resolution mode
        function updateSelectionBarForConflict() {
            // Find the action button (exclude the clear button)
            const actionBtn = document.querySelector('#selection-actions button:not(.btn-clear)');

            if (actionBtn && conflictResolutionContext) {
                actionBtn.innerHTML = '<i class="fas fa-check me-1"></i> Confirmar Alternativa';
                actionBtn.className = 'btn btn-success';

                // Capture current selection NOW - the button is recreated each time selection changes
                // so this will always be current. Capturing here prevents race conditions where
                // the selection might be cleared between button click and handler execution.
                const capturedSelection = [...map.getSelectedFurniture()];
                const selectedCount = capturedSelection.length;

                // Override click handler with captured selection
                actionBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    confirmAlternativeSelection(capturedSelection);
                };

                // Enable/disable based on count
                if (selectedCount !== conflictResolutionContext.requiredCount) {
                    actionBtn.disabled = true;
                    actionBtn.innerHTML += ` (${selectedCount}/${conflictResolutionContext.requiredCount})`;
                    actionBtn.classList.remove('btn-success');
                    actionBtn.classList.add('btn-secondary');
                } else {
                    actionBtn.disabled = false;
                    actionBtn.classList.remove('btn-secondary');
                    actionBtn.classList.add('btn-success');
                }
            }
        }

        // Confirm the alternative furniture selection
        // capturedSelection is passed from updateSelectionBarForConflict to avoid race conditions
        function confirmAlternativeSelection(capturedSelection) {
            if (!conflictResolutionContext) return;

            // Use the captured selection passed from the button click handler
            // This prevents issues where selection might be cleared between click and execution
            const selectedIds = capturedSelection || map.getSelectedFurniture();
            const requiredCount = parseInt(conflictResolutionContext.requiredCount);

            console.log('[Map] Confirming selection:', {
                selectedIds: selectedIds,
                count: selectedIds ? selectedIds.length : 'null',
                required: requiredCount,
                capturedFromButton: !!capturedSelection
            });

            // Validate exact count match
            if (selectedIds.length != requiredCount) {
                if (window.PuroBeach && window.PuroBeach.showToast) {
                    window.PuroBeach.showToast(
                        `Debes seleccionar exactamente ${requiredCount} hamaca(s)`,
                        'warning'
                    );
                }
                return;
            }

            // Dispatch event to notify the conflict modal
            // The modal will show again after this
            // Capture date BEFORE clearing context (setTimeout runs after context is nulled)
            const capturedDate = conflictResolutionContext.date;
            console.log('[Map] Dispatching alternativeSelected event:', capturedDate, selectedIds);

            // Small delay to ensure UI updates have processed
            setTimeout(() => {
                document.dispatchEvent(new CustomEvent('conflictResolution:alternativeSelected', {
                    detail: {
                        date: capturedDate,
                        furnitureIds: selectedIds
                    }
                }));
            }, 50);

            // Clear map state but keep context for potential further edits
            clearConflictHighlights();
            hideConflictInstructions();
            map.clearSelection();
            updateSelectionBar();

            // Clear context - the modal now manages the flow
            conflictResolutionContext = null;

            // Brief toast - the modal will show immediately after
            if (window.PuroBeach && window.PuroBeach.showToast) {
                window.PuroBeach.showToast('Alternativa guardada', 'success');
            }
        }

        // ==========================================================================
        // QUICK SWAP - Move blocking reservations to free up furniture
        // ==========================================================================
        let quickSwapContext = null;

        const quickSwapModal = document.getElementById('quickSwapModal');
        const quickSwapCancelBtn = document.getElementById('quickSwapCancelBtn');
        const quickSwapStartBtn = document.getElementById('quickSwapStartBtn');
        const quickSwapBackdrop = quickSwapModal.querySelector('.quick-swap-backdrop');

        // Show quick swap modal when clicking on a conflicting furniture
        function showQuickSwapModal(furnitureId, reservationId, customerName, furnitureLabel) {
            quickSwapContext = {
                fromFurnitureId: furnitureId,
                reservationId: reservationId,
                customerName: customerName,
                furnitureLabel: furnitureLabel,
                date: conflictResolutionContext ? conflictResolutionContext.date : map.getCurrentDate()
            };

            document.getElementById('quickSwapCustomerName').textContent = customerName || 'Cliente';
            document.getElementById('quickSwapFurnitureLabel').textContent = furnitureLabel || `#${furnitureId}`;
            document.getElementById('quickSwapSelectPrompt').style.display = 'none';

            quickSwapModal.style.display = 'flex';
            quickSwapModal.classList.remove('selecting-destination');
        }

        function hideQuickSwapModal() {
            quickSwapModal.style.display = 'none';
            quickSwapModal.classList.remove('selecting-destination');
            clearSwapSourceHighlight();
            quickSwapContext = null;
        }

        function enterSwapDestinationMode() {
            // Hide the modal - we'll use the instruction panel instead
            quickSwapModal.style.display = 'none';
            quickSwapModal.classList.add('selecting-destination');

            // Highlight the source furniture
            const sourceEl = document.querySelector(
                `.furniture-item[data-furniture-id="${quickSwapContext.fromFurnitureId}"]`
            );
            if (sourceEl) {
                sourceEl.classList.add('swap-source');
            }

            // Update the conflict instruction panel to show swap mode
            const instrPanel = document.getElementById('conflictInstructionPanel');
            if (instrPanel) {
                document.getElementById('conflictInstructionText').innerHTML =
                    `<i class="fas fa-exchange-alt text-warning"></i> Moviendo <strong>${quickSwapContext.furnitureLabel}</strong><br>` +
                    `Selecciona la hamaca de destino`;
                document.getElementById('conflictReplacingList').innerHTML =
                    `<small><button type="button" class="btn btn-sm btn-outline-secondary" id="cancelSwapBtn">` +
                    `<i class="fas fa-times"></i> Cancelar</button></small>`;

                // Bind cancel button
                document.getElementById('cancelSwapBtn').addEventListener('click', () => {
                    hideQuickSwapModal();
                    // Restore original instruction
                    if (conflictResolutionContext) {
                        showConflictInstructions(
                            conflictResolutionContext.conflicts,
                            conflictResolutionContext.requiredCount,
                            conflictResolutionContext.conflictingLabels
                        );
                    }
                });

                instrPanel.style.display = 'block';
            }
        }

        function clearSwapSourceHighlight() {
            document.querySelectorAll('.furniture-item.swap-source').forEach(el => {
                el.classList.remove('swap-source');
            });
        }

        // Perform the quick swap via API
        async function performQuickSwap(toFurnitureId) {
            if (!quickSwapContext) return;

            try {
                const response = await fetch('/beach/api/map/move-reservation-furniture', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
                    },
                    body: JSON.stringify({
                        reservation_id: quickSwapContext.reservationId,
                        date: quickSwapContext.date,
                        from_furniture_id: quickSwapContext.fromFurnitureId,
                        to_furniture_id: toFurnitureId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    if (window.PuroBeach && window.PuroBeach.showToast) {
                        window.PuroBeach.showToast(result.message || 'Reserva movida exitosamente', 'success');
                    }

                    // Refresh the map to show updated availability
                    await map.refreshAvailability();

                    // The conflicting furniture is now free
                    if (conflictResolutionContext) {
                        // Remove the moved furniture from conflicts list
                        conflictResolutionContext.conflicts = conflictResolutionContext.conflicts.filter(
                            c => c.furniture_id !== quickSwapContext.fromFurnitureId
                        );

                        // Update conflicting labels
                        conflictResolutionContext.conflictingLabels =
                            conflictResolutionContext.conflicts.map(c => c.furniture_number).join(', ');

                        // Update highlights
                        clearConflictHighlights();
                        if (conflictResolutionContext.conflicts.length > 0) {
                            highlightConflictingFurniture(conflictResolutionContext.conflicts);
                        }

                        // Restore the instruction panel with updated info
                        showConflictInstructions(
                            conflictResolutionContext.conflicts,
                            conflictResolutionContext.requiredCount,
                            conflictResolutionContext.conflictingLabels
                        );

                        // If no more conflicts, notify user they can now select
                        if (conflictResolutionContext.conflicts.length === 0) {
                            document.getElementById('conflictInstructionText').innerHTML =
                                `<i class="fas fa-check-circle text-success"></i> Conflicto resuelto<br>` +
                                `Selecciona ${conflictResolutionContext.requiredCount} hamaca(s)`;
                        }
                    }

                    hideQuickSwapModal();
                } else {
                    if (window.PuroBeach && window.PuroBeach.showToast) {
                        window.PuroBeach.showToast(result.error || 'Error al mover la reserva', 'error');
                    }
                }
            } catch (error) {
                console.error('Quick swap error:', error);
                if (window.PuroBeach && window.PuroBeach.showToast) {
                    window.PuroBeach.showToast('Error de conexi√≥n', 'error');
                }
            }
        }

        // Bind quick swap modal events
        quickSwapCancelBtn.addEventListener('click', hideQuickSwapModal);
        quickSwapBackdrop.addEventListener('click', hideQuickSwapModal);
        quickSwapStartBtn.addEventListener('click', enterSwapDestinationMode);

        // ==========================================================================
        // TOUCH HANDLER FOR RESERVATION DETAILS
        // ==========================================================================
        const mapContainer = document.getElementById('map-container');

        // Initialize touch handler for long-press detection
        const touchHandler = new TouchHandler(mapContainer, {
            longPressDelay: 500,
            vibrate: true
        });

        touchHandler.onLongPress(async (event) => {
            const { furnitureId, clientX, clientY } = event;

            // Check if furniture is occupied
            const data = map.getData();
            const availability = data.availability[furnitureId];

            if (availability && !availability.available && availability.reservation_id) {
                // Occupied furniture - open reservation panel directly
                openReservationPanel(availability.reservation_id, 'view');
            } else {
                // Available furniture - select it and open quick reservation
                map.clearSelection();
                map.selectFurniture(furnitureId, true);
                updateSelectionBar();
                openNewReservationPanel();
            }
        });

        // ==========================================================================
        // FURNITURE REASSIGNMENT MODE (In-Panel)
        // ==========================================================================
        // Reassignment is now handled in the ReservationPanel itself
        // This section provides map coordination when panel is in reassignment mode
        let panelReassignmentMode = false;
        let panelReassignmentOriginalFurniture = [];

        /**
         * Called when panel enters reassignment mode
         */
        function enterPanelReassignmentMode(reservationId, currentFurniture, numPeople) {
            panelReassignmentMode = true;
            panelReassignmentOriginalFurniture = currentFurniture.map(f => f.furniture_id);

            // Clear map selection
            map.clearSelection();
            map.render();

            // Update touch handlers for reassignment mode
            touchHandler.onLongPress(null);  // Disable long-press during reassignment
            touchHandler.onTap((event) => {
                const { furnitureId } = event;
                const data = map.getData();
                const availability = data.availability[furnitureId];

                // Can only select available furniture or furniture in current reservation
                const isOriginalFurniture = panelReassignmentOriginalFurniture.includes(furnitureId);
                if (availability && !availability.available && !isOriginalFurniture) {
                    if (window.PuroBeach && window.PuroBeach.showToast) {
                        window.PuroBeach.showToast('Este mobiliario tiene otra reserva', 'warning');
                    }
                    return;
                }

                // Get furniture data for the panel
                const furnitureData = data.furniture.find(f => f.id === furnitureId);

                // Toggle selection in the panel (panel manages state)
                const wasToggled = reservationPanel.toggleFurnitureSelection(furnitureId, furnitureData);

                if (wasToggled) {
                    // Update map visual selection to match panel state
                    const isNowSelected = reservationPanel.reassignmentState.selectedFurniture.some(
                        f => (f.id || f) === furnitureId
                    );
                    if (isNowSelected) {
                        map.selectFurniture(furnitureId, true);
                    } else {
                        map.deselectFurniture(furnitureId);
                    }
                    map.render();
                }
            });
        }

        /**
         * Called when panel exits reassignment mode
         */
        function exitPanelReassignmentMode() {
            panelReassignmentMode = false;
            panelReassignmentOriginalFurniture = [];

            // Clear map selection
            map.clearSelection();
            updateSelectionBar();

            // Restore normal touch handler behavior
            touchHandler.onLongPress(async (event) => {
                const { furnitureId } = event;
                const data = map.getData();
                const availability = data.availability[furnitureId];

                if (availability && !availability.available && availability.reservation_id) {
                    openReservationPanel(availability.reservation_id, 'view');
                } else {
                    map.clearSelection();
                    map.selectFurniture(furnitureId, true);
                    updateSelectionBar();
                    openNewReservationPanel();
                }
            });

            touchHandler.onTap(null);  // Use default click handler
        }

        // ==========================================================================
        // DATE NAVIGATION
        // ==========================================================================
        const dateDisplay = document.getElementById('date-display');
        const datePicker = document.getElementById('date-picker');
        const btnPrevDay = document.getElementById('btn-prev-day');
        const btnNextDay = document.getElementById('btn-next-day');

        // Format date for display (compact for mobile)
        function formatDateCompact(dateStr) {
            const date = new Date(dateStr + 'T12:00:00');
            const day = date.getDate();
            const month = date.toLocaleDateString('es-ES', { month: 'short' });
            return `${day} ${month.charAt(0).toUpperCase() + month.slice(1)}`;
        }

        map.on('onDateChange', function (dateStr) {
            dateDisplay.textContent = formatDateCompact(dateStr);
            datePicker.value = dateStr;
            updateStats(currentZoneId);
            populateZoneSelector();
        });

        btnPrevDay.addEventListener('click', async () => {
            btnPrevDay.disabled = true;
            await map.goToPreviousDay();
            btnPrevDay.disabled = false;
        });

        btnNextDay.addEventListener('click', async () => {
            btnNextDay.disabled = true;
            await map.goToNextDay();
            btnNextDay.disabled = false;
        });

        // Click on date to open picker
        dateDisplay.addEventListener('click', () => {
            datePicker.classList.toggle('show');
            if (datePicker.classList.contains('show')) {
                datePicker.focus();
                datePicker.showPicker && datePicker.showPicker();
            }
        });

        datePicker.addEventListener('change', async (e) => {
            await map.goToDate(e.target.value);
            datePicker.classList.remove('show');
        });

        datePicker.addEventListener('blur', () => {
            setTimeout(() => datePicker.classList.remove('show'), 200);
        });

        // Swipe date navigation on mobile
        let touchStartX = 0;
        dateDisplay.addEventListener('touchstart', (e) => {
            touchStartX = e.touches[0].clientX;
        }, { passive: true });

        dateDisplay.addEventListener('touchend', (e) => {
            const diff = e.changedTouches[0].clientX - touchStartX;
            if (Math.abs(diff) > 50) {
                if (diff > 0) map.goToPreviousDay();
                else map.goToNextDay();
            }
        }, { passive: true });

        // Set initial date
        datePicker.value = map.getCurrentDate();
        setTimeout(() => {
            dateDisplay.textContent = formatDateCompact(map.getCurrentDate());
            updateStats();
            populateZoneSelector();
        }, 500);

        // ==========================================================================
        // ZONE SELECTOR
        // ==========================================================================
        const zoneSelect = document.getElementById('zone-select');
        let currentZoneId = null;

        function populateZoneSelector() {
            const data = map.getData();
            if (!data || !data.zones || data.zones.length === 0) return;

            const currentValue = zoneSelect.value;
            zoneSelect.innerHTML = '';

            data.zones.forEach(zone => {
                const option = document.createElement('option');
                option.value = zone.id;
                option.textContent = zone.name;
                zoneSelect.appendChild(option);
            });

            if (currentValue && data.zones.some(z => z.id == currentValue)) {
                zoneSelect.value = currentValue;
            } else {
                zoneSelect.value = data.zones[0].id;
            }

            currentZoneId = parseInt(zoneSelect.value);
            applyZoneView(currentZoneId);
        }

        zoneSelect.addEventListener('change', () => {
            currentZoneId = parseInt(zoneSelect.value);
            applyZoneView(currentZoneId);
        });

        function applyZoneView(zoneId) {
            const data = map.getData();
            if (!data) return;

            // Show only furniture in selected zone
            document.querySelectorAll('.furniture-item').forEach(item => {
                const furnitureId = parseInt(item.dataset.furnitureId);
                const furniture = data.furniture?.find(f => f.id === furnitureId);
                if (!furniture) return;
                item.style.display = furniture.zone_id === zoneId ? '' : 'none';
            });

            // Show only decorative items in selected zone
            document.querySelectorAll('.decorative-item').forEach(item => {
                const furnitureId = parseInt(item.dataset.furnitureId);
                const furniture = data.furniture?.find(f => f.id === furnitureId);
                if (!furniture) return;
                item.style.display = furniture.zone_id === zoneId ? '' : 'none';
            });

            updateStats(zoneId);
            adjustViewBoxForZone(zoneId);
        }

        function adjustViewBoxForZone(zoneId) {
            const data = map.getData();
            if (!data) return;

            const svg = document.getElementById('beach-map');
            if (!svg) return;

            // Get zone's canvas dimensions (more accurate than map_dimensions)
            const zone = data.zones?.find(z => z.id === zoneId);
            const canvasWidth = zone?.canvas_width || data.map_dimensions?.width || 1200;
            const canvasHeight = zone?.canvas_height || data.map_dimensions?.height || 800;

            // Use the zone's full canvas dimensions (matches map editor)
            svg.setAttribute('viewBox', `0 0 ${canvasWidth} ${canvasHeight}`);
        }

        // ==========================================================================
        // STATS
        // ==========================================================================
        function updateStats(zoneId = null) {
            const data = map.getData();
            if (!data || !data.furniture) return;

            // Filter out decorative items
            let furniture = data.furniture.filter(f => {
                const typeConfig = data.furniture_types[f.furniture_type] || {};
                return typeConfig.is_decorative !== 1;
            });

            if (zoneId !== null) {
                furniture = furniture.filter(f => f.zone_id === zoneId);
            }

            const total = furniture.length;
            let available = 0;
            let occupied = 0;

            furniture.forEach(f => {
                const avail = data.availability[f.id];
                if (!avail || avail.available) {
                    available++;
                } else {
                    occupied++;
                }
            });

            const rate = total > 0 ? Math.round((occupied / total) * 100) : 0;

            document.getElementById('stat-total').textContent = total;
            document.getElementById('stat-available').textContent = available;
            document.getElementById('stat-occupied').textContent = occupied;
            document.getElementById('stat-rate').textContent = `${rate}%`;
        }

        // ==========================================================================
        // CANVAS INFO BAR
        // ==========================================================================
        const canvasDimensions = document.getElementById('canvas-dimensions');
        const cursorPos = document.getElementById('cursor-pos');
        const furnitureCount = document.getElementById('furniture-count');
        const zoomLevel = document.getElementById('zoom-level');

        function updateCanvasInfo() {
            const data = map.getData();
            if (!data) return;

            // Get zone's canvas dimensions
            const zone = data.zones?.find(z => z.id === currentZoneId);
            const width = zone?.canvas_width || data.map_dimensions?.width || 1200;
            const height = zone?.canvas_height || data.map_dimensions?.height || 800;

            canvasDimensions.textContent = `${width} x ${height}`;

            // Count visible furniture (in current zone, non-decorative)
            const visibleCount = data.furniture?.filter(f => {
                if (f.zone_id !== currentZoneId) return false;
                const typeConfig = data.furniture_types[f.furniture_type] || {};
                return typeConfig.is_decorative !== 1;
            }).length || 0;

            furnitureCount.textContent = visibleCount;

            // Update zoom level
            updateZoomDisplay();
        }

        function updateZoomDisplay() {
            const zoom = map.getZoom ? map.getZoom() : 1;
            zoomLevel.textContent = `${Math.round(zoom * 100)}%`;
        }

        // Track cursor position over canvas
        const mapCanvas = document.querySelector('.map-canvas');
        mapCanvas?.addEventListener('mousemove', (e) => {
            const svg = document.getElementById('beach-map');
            if (!svg) return;

            const rect = svg.getBoundingClientRect();
            const viewBox = svg.getAttribute('viewBox')?.split(' ').map(Number) || [0, 0, 1200, 800];

            // Convert screen coords to SVG coords
            const scaleX = viewBox[2] / rect.width;
            const scaleY = viewBox[3] / rect.height;

            const x = Math.round((e.clientX - rect.left) * scaleX);
            const y = Math.round((e.clientY - rect.top) * scaleY);

            cursorPos.textContent = `${x}, ${y}`;
        });

        mapCanvas?.addEventListener('mouseleave', () => {
            cursorPos.textContent = '-';
        });

        // Update info after render
        map.on('onRender', () => {
            updateCanvasInfo();
        });

        // ==========================================================================
        // ZOOM CONTROLS
        // ==========================================================================
        document.getElementById('btn-zoom-in').addEventListener('click', () => { map.zoomIn(); updateZoomDisplay(); });
        document.getElementById('btn-zoom-out').addEventListener('click', () => { map.zoomOut(); updateZoomDisplay(); });

        // Info bar zoom controls
        document.getElementById('btn-zoom-in-bar')?.addEventListener('click', () => { map.zoomIn(); updateZoomDisplay(); });
        document.getElementById('btn-zoom-out-bar')?.addEventListener('click', () => { map.zoomOut(); updateZoomDisplay(); });
        document.getElementById('btn-zoom-reset')?.addEventListener('click', () => { resetToSavedView(); });
        document.getElementById('btn-save-view')?.addEventListener('click', () => { saveCurrentView(); });

        // ==========================================================================
        // SAVE/RESTORE VIEW
        // ==========================================================================
        const VIEW_STORAGE_KEY = 'beachMap_savedView';
        let savedView = null;

        // Load saved view on init
        function loadSavedView() {
            try {
                const saved = localStorage.getItem(VIEW_STORAGE_KEY);
                if (saved) {
                    savedView = JSON.parse(saved);
                }
            } catch (e) {
                console.warn('Could not load saved view:', e);
            }
        }

        // Save current view (zoom + scroll position)
        function saveCurrentView() {
            const view = {
                zoom: map.getZoom ? map.getZoom() : 1,
                scrollLeft: mapWrapper.scrollLeft,
                scrollTop: mapWrapper.scrollTop,
                zoneId: currentZoneId
            };

            savedView = view;

            try {
                localStorage.setItem(VIEW_STORAGE_KEY, JSON.stringify(view));
                // Visual feedback
                const btn = document.getElementById('btn-save-view');
                btn.innerHTML = '<i class="fas fa-check"></i>';
                btn.style.color = 'var(--color-success)';
                setTimeout(() => {
                    btn.innerHTML = '<i class="fas fa-save"></i>';
                    btn.style.color = '';
                }, 1500);
            } catch (e) {
                console.warn('Could not save view:', e);
            }
        }

        // Reset to saved view or default
        function resetToSavedView() {
            if (savedView) {
                // Restore zoom
                map.setZoom(savedView.zoom || 1);
                updateZoomDisplay();

                // Restore scroll position after a short delay (for zoom to apply)
                setTimeout(() => {
                    mapWrapper.scrollLeft = savedView.scrollLeft || 0;
                    mapWrapper.scrollTop = savedView.scrollTop || 0;
                }, 50);

                // Restore zone if different
                if (savedView.zoneId && savedView.zoneId !== currentZoneId) {
                    zoneSelect.value = savedView.zoneId;
                    currentZoneId = savedView.zoneId;
                    applyZoneView(currentZoneId);
                }
            } else {
                // Default: zoom 100%, scroll to origin
                map.setZoom(1);
                updateZoomDisplay();
                mapWrapper.scrollLeft = 0;
                mapWrapper.scrollTop = 0;
            }
        }

        // Load saved view on page load
        loadSavedView();

        // ==========================================================================
        // MAP EDITOR STYLE NAVIGATION (Ctrl+Wheel Zoom, Space+Drag Pan)
        // ==========================================================================
        const mapWrapper = document.querySelector('.map-canvas-wrapper');
        let spaceDown = false;
        let isPanning = false;
        let panStart = { x: 0, y: 0 };
        let scrollStart = { x: 0, y: 0 };

        // Shift+Wheel Zoom (zoom to mouse position)
        // Using Shift instead of Ctrl to avoid conflict with browser zoom
        document.addEventListener('wheel', (e) => {
            // Only handle if Shift is pressed and mouse is over the map
            if (!e.shiftKey) return;

            // Check if event is within map wrapper
            if (!mapWrapper.contains(e.target)) return;

            // Prevent default scroll behavior
            e.preventDefault();
            e.stopPropagation();

            const svg = document.getElementById('beach-map');
            if (!svg) return;

            // Get current zoom
            const currentZoom = map.getZoom ? map.getZoom() : 1;

            // Use percentage-based zoom for smoother experience at all zoom levels
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;  // 10% change
            const minZoom = 0.1;
            const maxZoom = 3;
            const newZoom = Math.max(minZoom, Math.min(currentZoom * zoomFactor, maxZoom));

            // Skip if zoom didn't change (hit min/max)
            if (Math.abs(newZoom - currentZoom) < 0.001) return;

            // Get wrapper dimensions
            const wrapperRect = mapWrapper.getBoundingClientRect();
            const wrapperWidth = mapWrapper.clientWidth;
            const wrapperHeight = mapWrapper.clientHeight;

            // Get SVG rect
            const svgRect = svg.getBoundingClientRect();

            // Mouse position relative to wrapper viewport
            const mouseXInWrapper = e.clientX - wrapperRect.left;
            const mouseYInWrapper = e.clientY - wrapperRect.top;

            // Calculate mouse position relative to SVG (clamp to SVG bounds)
            const mouseXInSvg = Math.max(0, Math.min(e.clientX - svgRect.left, svgRect.width));
            const mouseYInSvg = Math.max(0, Math.min(e.clientY - svgRect.top, svgRect.height));

            // Convert to canvas coordinates (the actual viewBox coordinates)
            const canvasX = mouseXInSvg / currentZoom;
            const canvasY = mouseYInSvg / currentZoom;

            // Get current SVG dimensions
            const currentSvgWidth = svgRect.width;
            const currentSvgHeight = svgRect.height;

            // Calculate new SVG dimensions after zoom
            const zoomRatio = newZoom / currentZoom;
            const newSvgWidth = currentSvgWidth * zoomRatio;
            const newSvgHeight = currentSvgHeight * zoomRatio;

            // Calculate centering offset after zoom
            const padding = 10;
            const availableWidth = wrapperWidth - padding * 2;
            const availableHeight = wrapperHeight - padding * 2;
            const newCenterOffsetX = Math.max(0, (availableWidth - newSvgWidth) / 2);
            const newCenterOffsetY = Math.max(0, (availableHeight - newSvgHeight) / 2);

            // Apply zoom
            map.setZoom(newZoom);
            updateZoomDisplay();

            // Calculate new scroll position
            requestAnimationFrame(() => {
                // The canvas point position in the new SVG
                const newPointXInSvg = canvasX * newZoom;
                const newPointYInSvg = canvasY * newZoom;

                // Target scroll: position the point under the mouse
                const targetScrollX = padding + newCenterOffsetX + newPointXInSvg - mouseXInWrapper;
                const targetScrollY = padding + newCenterOffsetY + newPointYInSvg - mouseYInWrapper;

                mapWrapper.scrollLeft = Math.max(0, targetScrollX);
                mapWrapper.scrollTop = Math.max(0, targetScrollY);
            });
        }, { passive: false, capture: true });

        // Track space key for pan mode
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spaceDown && document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                e.preventDefault();
                spaceDown = true;
                mapWrapper.style.cursor = 'grab';
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spaceDown = false;
                if (!isPanning) {
                    mapWrapper.style.cursor = '';
                }
            }
        });

        // Space+Drag or Middle Mouse Button Pan
        mapWrapper.addEventListener('mousedown', (e) => {
            // Middle mouse button (1) or space + left click (0)
            if (e.button === 1 || (e.button === 0 && spaceDown)) {
                e.preventDefault();
                isPanning = true;
                panStart = { x: e.clientX, y: e.clientY };
                scrollStart = { x: mapWrapper.scrollLeft, y: mapWrapper.scrollTop };
                mapWrapper.style.cursor = 'grabbing';
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - panStart.x;
            const dy = e.clientY - panStart.y;
            mapWrapper.scrollLeft = scrollStart.x - dx;
            mapWrapper.scrollTop = scrollStart.y - dy;
        });

        document.addEventListener('mouseup', (e) => {
            if (isPanning) {
                isPanning = false;
                mapWrapper.style.cursor = spaceDown ? 'grab' : '';
            }
        });

        // Prevent default middle click behavior
        mapWrapper.addEventListener('auxclick', (e) => {
            if (e.button === 1) e.preventDefault();
        });

        // ==========================================================================
        // KEYBOARD SHORTCUTS (Map Editor Style)
        // ==========================================================================
        document.addEventListener('keydown', (e) => {
            const isInputFocused = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA';
            const hasSelection = map.getSelectedFurniture && map.getSelectedFurniture().length > 0;

            switch (e.key) {
                case 'Escape':
                    // Close new reservation panel if open
                    if (newReservationPanel.isOpen()) {
                        newReservationPanel.close();
                    } else {
                        // Deselect all
                        map.clearSelection();
                        updateSelectionBar();
                    }
                    break;

                case 'a':
                case 'A':
                    // Ctrl+A: Select all visible furniture
                    if ((e.ctrlKey || e.metaKey) && !isInputFocused) {
                        e.preventDefault();
                        selectAllVisibleFurniture();
                    }
                    break;

                case '+':
                case '=':
                    // Ctrl++: Zoom in
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        map.zoomIn();
                        updateZoomDisplay();
                    }
                    break;

                case '-':
                    // Ctrl+-: Zoom out
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        map.zoomOut();
                        updateZoomDisplay();
                    }
                    break;

                case '0':
                    // Ctrl+0: Reset to saved view
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        resetToSavedView();
                    }
                    break;

                case 'ArrowLeft':
                    // Navigate to previous day
                    if (!isInputFocused && !hasSelection) {
                        e.preventDefault();
                        map.goToPreviousDay();
                    }
                    break;

                case 'ArrowRight':
                    // Navigate to next day
                    if (!isInputFocused && !hasSelection) {
                        e.preventDefault();
                        map.goToNextDay();
                    }
                    break;

                case 'r':
                case 'R':
                    // R: Refresh
                    if (!e.ctrlKey && !e.metaKey && !isInputFocused) {
                        e.preventDefault();
                        btnRefresh.click();
                    }
                    break;

                case 's':
                case 'S':
                    // Ctrl+S: Save view
                    if ((e.ctrlKey || e.metaKey) && !isInputFocused) {
                        e.preventDefault();
                        saveCurrentView();
                    }
                    break;
            }
        });

        // Select all visible furniture in current zone
        function selectAllVisibleFurniture() {
            const data = map.getData();
            if (!data || !data.furniture) return;

            // Get visible furniture (in current zone, not decorative)
            const visibleFurniture = data.furniture.filter(f => {
                if (f.zone_id !== currentZoneId) return false;
                const typeConfig = data.furniture_types[f.furniture_type] || {};
                return typeConfig.is_decorative !== 1;
            });

            visibleFurniture.forEach(f => {
                map.selectFurniture(f.id, true); // true = add to selection
            });

            updateSelectionBar();
        }

        // ==========================================================================
        // REFRESH
        // ==========================================================================
        const btnRefresh = document.getElementById('btn-refresh');
        btnRefresh.addEventListener('click', async () => {
            btnRefresh.querySelector('i').classList.add('fa-spin');
            await map.refreshAvailability();
            updateStats(currentZoneId);
            setTimeout(() => btnRefresh.querySelector('i').classList.remove('fa-spin'), 500);
        });

        map.startAutoRefresh(30000);

        // ==========================================================================
        // SELECTION & BOTTOM ACTION BAR
        // ==========================================================================
        const selectionBar = document.getElementById('selection-bar');
        const selectedBadges = document.getElementById('selected-badges');
        const totalCapacity = document.getElementById('total-capacity');

        function updateSelectionBar() {
            const selected = map.getSelectedFurnitureData();

            if (selected.length === 0) {
                selectionBar.classList.remove('show');
                return;
            }

            selectionBar.classList.add('show');

            // Check availability status of selected furniture
            const data = map.getData();
            const availability = data.availability || {};

            let occupiedFurniture = [];
            let availableFurniture = [];
            let reservationIds = new Set();

            selected.forEach(f => {
                const avail = availability[f.id];
                if (avail && !avail.available) {
                    occupiedFurniture.push({ ...f, reservation_id: avail.reservation_id });
                    if (avail.reservation_id) {
                        reservationIds.add(avail.reservation_id);
                    }
                } else {
                    availableFurniture.push(f);
                }
            });

            // Build chips with visual indicator for occupied
            selectedBadges.innerHTML = selected.map(f => {
                const avail = availability[f.id];
                const isOccupied = avail && !avail.available;
                const chipStyle = isOccupied ?
                    'background: rgba(220, 53, 69, 0.15); border-color: #dc3545;' : '';

                return `
                <span class="selection-chip" data-id="${f.id}" style="${chipStyle}">
                    ${f.number}
                    ${isOccupied ? '<i class="fas fa-user" style="font-size: 8px; margin-left: 2px; opacity: 0.7;"></i>' : ''}
                    <span class="remove-chip" data-id="${f.id}"><i class="fas fa-times"></i></span>
                </span>
            `;
            }).join('');

            // Add remove handlers
            selectedBadges.querySelectorAll('.remove-chip').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const id = parseInt(btn.dataset.id);
                    map.deselectFurniture(id);
                    updateSelectionBar();
                });
            });

            // Calculate total capacity
            const capacity = selected.reduce((sum, f) => sum + (f.capacity || 2), 0);
            totalCapacity.textContent = capacity;

            // Update action button based on selection type
            updateSelectionActions(availableFurniture, occupiedFurniture, reservationIds);

            // If in conflict resolution mode, override the button
            if (conflictResolutionContext) {
                updateSelectionBarForConflict();
            }
        }

        function updateSelectionActions(availableFurniture, occupiedFurniture, reservationIds) {
            const actionsContainer = document.getElementById('selection-actions');
            const clearBtn = document.getElementById('btn-clear-selection');

            // Determine the action type
            const allAvailable = occupiedFurniture.length === 0;
            const allOccupied = availableFurniture.length === 0;
            const singleReservation = reservationIds.size === 1;

            // Clear existing action button (keep clear button)
            // Include btn-success and btn-secondary which are set by updateSelectionBarForConflict
            const existingActionBtn = actionsContainer.querySelector('.btn-reserve, .btn-view-reservation, .btn-mixed, .btn-success, .btn-secondary');
            if (existingActionBtn) {
                existingActionBtn.remove();
            }

            let actionBtn;

            if (allAvailable) {
                // All available - show "Reservar" button
                actionBtn = document.createElement('button');
                actionBtn.type = 'button';
                actionBtn.className = 'btn-reserve';
                actionBtn.id = 'btn-new-reservation';
                actionBtn.innerHTML = '<i class="fas fa-calendar-plus"></i> <span>Reservar</span>';
                actionBtn.addEventListener('click', openNewReservationPanel);

            } else if (allOccupied && singleReservation) {
                // All from same reservation - show "Ver Reserva" button
                const reservationId = Array.from(reservationIds)[0];
                actionBtn = document.createElement('button');
                actionBtn.type = 'button';
                actionBtn.className = 'btn-view-reservation';
                actionBtn.style.cssText = 'background: linear-gradient(135deg, #1A3A5C 0%, #2d5a87 100%); color: white; padding: 10px 16px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 6px;';
                actionBtn.innerHTML = '<i class="fas fa-eye"></i> <span>Ver Reserva</span>';
                actionBtn.addEventListener('click', () => {
                    openReservationPanel(reservationId, 'view');
                });

            } else if (allOccupied) {
                // Multiple reservations selected
                actionBtn = document.createElement('button');
                actionBtn.type = 'button';
                actionBtn.className = 'btn-view-reservation';
                actionBtn.style.cssText = 'background: #6c757d; color: white; padding: 10px 16px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 6px;';
                actionBtn.innerHTML = `<i class="fas fa-layer-group"></i> <span>${reservationIds.size} Reservas</span>`;
                actionBtn.addEventListener('click', () => {
                    alert(`Hay ${reservationIds.size} reservas diferentes seleccionadas. Seleccione mobiliario de una sola reserva para ver detalles.`);
                });

            } else {
                // Mixed selection (some available, some occupied)
                actionBtn = document.createElement('button');
                actionBtn.type = 'button';
                actionBtn.className = 'btn-mixed';
                actionBtn.style.cssText = 'background: linear-gradient(135deg, #D4AF37 0%, #B8960C 100%); color: white; padding: 10px 16px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; display: flex; align-items: center; gap: 6px;';
                actionBtn.innerHTML = `<i class="fas fa-calendar-plus"></i> <span>Reservar ${availableFurniture.length}</span>`;
                actionBtn.title = `Reservar solo los ${availableFurniture.length} mobiliarios disponibles`;
                actionBtn.addEventListener('click', () => {
                    // Deselect occupied furniture and open reservation sheet
                    occupiedFurniture.forEach(f => map.deselectFurniture(f.id));
                    updateSelectionBar();
                    openNewReservationPanel();
                });
            }

            actionsContainer.appendChild(actionBtn);
        }

        // Override map selection callback - handle occupied furniture clicks
        map.on('onFurnitureClick', async (item, selectedFurniture) => {
            try {
                const data = map.getData();
                const availability = data.availability[item.id];

                // Handle panel reassignment mode
                // Note: map.handleFurnitureClick already called selectFurniture before this callback
                if (panelReassignmentMode) {
                    const furnitureId = item.id;

                    // Can only select available furniture or furniture in current reservation's original assignment
                    const isOriginalFurniture = panelReassignmentOriginalFurniture.includes(furnitureId);
                    if (availability && !availability.available && !isOriginalFurniture) {
                        // This furniture belongs to another reservation - can't select
                        map.deselectFurniture(furnitureId);
                        if (window.PuroBeach && window.PuroBeach.showToast) {
                            window.PuroBeach.showToast('Este mobiliario tiene otra reserva', 'warning');
                        }
                        return;
                    }

                    // Get furniture data for the panel
                    const furnitureData = data.furniture.find(f => f.id === furnitureId);

                    // Toggle selection in the panel (panel manages state)
                    const wasToggled = reservationPanel.toggleFurnitureSelection(furnitureId, furnitureData);

                    if (!wasToggled) {
                        // Panel rejected the toggle (e.g., at max limit) - revert map selection
                        map.deselectFurniture(furnitureId);
                    } else {
                        // Sync map selection with panel state
                        const isNowSelected = reservationPanel.reassignmentState.selectedFurniture.some(
                            f => (f.id || f) === furnitureId
                        );
                        if (!isNowSelected) {
                            map.deselectFurniture(furnitureId);
                        }
                    }
                    map.render();
                    return;
                }

                // Handle quick swap destination selection
                if (quickSwapContext && quickSwapModal.classList.contains('selecting-destination')) {
                    map.deselectFurniture(item.id); // Don't select during swap

                    if (availability && availability.available) {
                        // Available furniture - perform the swap
                        performQuickSwap(item.id);
                    } else {
                        // Can't swap to occupied furniture
                        if (window.PuroBeach && window.PuroBeach.showToast) {
                            window.PuroBeach.showToast('Selecciona una hamaca disponible', 'warning');
                        }
                    }
                    return;
                }

                // Handle conflict resolution mode - show quick swap for occupied furniture
                if (conflictResolutionContext && availability && !availability.available) {
                    map.deselectFurniture(item.id); // Don't select occupied furniture

                    // Check if this is one of the conflicting furniture items
                    const isConflicting = conflictResolutionContext.conflicts.some(
                        c => c.furniture_id === item.id
                    );

                    if (isConflicting) {
                        // Get conflict details for quick swap
                        const conflict = conflictResolutionContext.conflicts.find(
                            c => c.furniture_id === item.id
                        );
                        const furnitureData = data.furniture.find(f => f.id === item.id);

                        showQuickSwapModal(
                            item.id,
                            availability.reservation_id,
                            conflict.customer_name || availability.customer_name,
                            furnitureData?.number || conflict.furniture_number
                        );
                    } else {
                        // Occupied but not conflicting - just show message
                        if (window.PuroBeach && window.PuroBeach.showToast) {
                            window.PuroBeach.showToast('Esta hamaca est√° ocupada', 'info');
                        }
                    }
                    updateConflictSelectionCounter();
                    return;
                }

                // Normal mode - check if clicked furniture is occupied
                if (availability && !availability.available && availability.reservation_id) {
                    // Occupied furniture - deselect it and open reservation panel
                    map.deselectFurniture(item.id);
                    openReservationPanel(availability.reservation_id, 'view');
                }
                updateSelectionBar();
                updateConflictSelectionCounter();
            } catch (error) {
                console.error('Error in onFurnitureClick callback:', error);
                updateSelectionBar();
                updateConflictSelectionCounter();
            }
        });

        document.getElementById('btn-clear-selection').addEventListener('click', () => {
            map.clearSelection();
            updateSelectionBar();
            updateConflictSelectionCounter();
        });

        // ==========================================================================
        // NEW RESERVATION BUTTON
        // ==========================================================================
        const btnNewReservation = document.getElementById('btn-new-reservation');
        btnNewReservation.addEventListener('click', openNewReservationPanel);

        // ==========================================================================
        // BLOCK SELECTED BUTTON
        // ==========================================================================
        const btnBlockSelection = document.getElementById('btn-block-selection');
        if (btnBlockSelection) {
            btnBlockSelection.addEventListener('click', () => {
                const selected = map.getSelectedFurnitureData();
                if (selected.length === 0) {
                    window.PuroBeach.showToast('Selecciona mobiliario primero', 'warning');
                    return;
                }
                const ids = selected.map(f => f.id);
                const numbers = selected.map(f => f.number);
                blockManager.showBlockModal(ids, numbers);
            });
        }

        // ==========================================================================
        // CONTEXT MENU
        // ==========================================================================
        const contextMenu = document.getElementById('contextMenu');
        const contextMenuHeader = document.getElementById('context-menu-header');
        const contextMenuAvailable = document.getElementById('context-menu-available');
        const contextMenuOccupied = document.getElementById('context-menu-occupied');
        let contextFurnitureId = null;
        let contextReservationId = null;

        document.addEventListener('click', () => contextMenu.classList.add('d-none'));
        document.addEventListener('contextmenu', (e) => {
            if (!e.target.closest('.furniture-item') && !e.target.closest('.context-menu')) {
                contextMenu.classList.add('d-none');
            }
        });

        async function showContextMenu(furnitureId, event) {
            event.preventDefault();
            event.stopPropagation();

            try {
                const response = await fetch(`/beach/api/map/furniture/${furnitureId}/details?date=${map.getCurrentDate()}`);
                const data = await response.json();

                if (!data.success) return;

                contextFurnitureId = furnitureId;
                contextReservationId = data.reservation?.id || null;

                contextMenuHeader.textContent = `${data.furniture.type_name} #${data.furniture.number}`;

                contextMenuAvailable.classList.add('d-none');
                contextMenuOccupied.classList.add('d-none');

                if (data.reservation) {
                    contextMenuOccupied.classList.remove('d-none');
                } else {
                    contextMenuAvailable.classList.remove('d-none');
                }

                // Position menu
                let left = event.clientX;
                let top = event.clientY;

                if (left + 180 > window.innerWidth - 10) {
                    left = window.innerWidth - 190;
                }
                if (top + 200 > window.innerHeight - 10) {
                    top = window.innerHeight - 210;
                }

                contextMenu.style.left = `${left}px`;
                contextMenu.style.top = `${top}px`;
                contextMenu.classList.remove('d-none');

            } catch (error) {
                console.error('Error showing context menu:', error);
            }
        }

        document.getElementById('map-container').addEventListener('contextmenu', (e) => {
            const furnitureItem = e.target.closest('.furniture-item');
            if (furnitureItem) {
                const furnitureId = parseInt(furnitureItem.dataset.furnitureId);
                if (furnitureId) showContextMenu(furnitureId, e);
            }
        });

        contextMenu.addEventListener('click', async (e) => {
            const menuItem = e.target.closest('.context-menu-item');
            if (!menuItem) return;

            const action = menuItem.dataset.action;
            contextMenu.classList.add('d-none');

            switch (action) {
                case 'view-details':
                    // TODO: Show details modal
                    break;
                case 'select':
                    if (contextFurnitureId) {
                        map.selectFurniture(contextFurnitureId, true);
                        updateSelectionBar();
                    }
                    break;
                case 'new-reservation':
                    if (contextFurnitureId) {
                        map.clearSelection();
                        map.selectFurniture(contextFurnitureId);
                        updateSelectionBar();
                        openNewReservationPanel();
                    }
                    break;
                case 'view-reservation':
                    if (contextReservationId) {
                        window.location.href = `/beach/reservations/${contextReservationId}`;
                    }
                    break;
                case 'edit-reservation':
                    if (contextReservationId) {
                        window.location.href = `/beach/reservations/${contextReservationId}/edit`;
                    }
                    break;
                case 'cancel-reservation':
                    if (contextReservationId && confirm('Cancelar esta reserva?')) {
                        try {
                            const response = await fetch(`/beach/api/reservations/${contextReservationId}/toggle-state`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                    'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
                                },
                                body: JSON.stringify({ state: 'Cancelada', action: 'set' })
                            });
                            const data = await response.json();
                            if (data.success) {
                                await map.refreshAvailability();
                                updateStats(currentZoneId);
                            } else {
                                alert(data.error || 'Error al cancelar');
                            }
                        } catch (error) {
                            console.error('Error canceling:', error);
                        }
                    }
                    break;
                case 'block':
                    if (contextFurnitureId) {
                        const today = map.getCurrentDate();
                        if (confirm(`Bloquear mobiliario para ${formatDateCompact(today)}?`)) {
                            try {
                                const response = await fetch(`/beach/api/map/furniture/${contextFurnitureId}/block`, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json',
                                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
                                    },
                                    body: JSON.stringify({
                                        start_date: today,
                                        end_date: today,
                                        block_type: 'maintenance',
                                        reason: 'Bloqueado desde mapa'
                                    })
                                });
                                const data = await response.json();
                                if (data.success) {
                                    await map.refreshAvailability();
                                    updateStats(currentZoneId);
                                }
                            } catch (error) {
                                console.error('Error blocking:', error);
                            }
                        }
                    }
                    break;
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                contextMenu.classList.add('d-none');
                if (newReservationPanel.isOpen()) {
                    newReservationPanel.close();
                }
            }
        });

        // Apply zone view after every render
        map.on('onRender', () => {
            if (currentZoneId) {
                applyZoneView(currentZoneId);
            } else {
                populateZoneSelector();
            }
        });

    });


</script>
{% endblock %}